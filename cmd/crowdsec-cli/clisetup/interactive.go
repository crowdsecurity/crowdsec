package clisetup

import (
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"slices"
	"strings"

	"github.com/spf13/cobra"
	"github.com/AlecAivazis/survey/v2"
	"gopkg.in/yaml.v3"
	"github.com/sirupsen/logrus"

	"github.com/crowdsecurity/crowdsec/pkg/csconfig"
	"github.com/crowdsecurity/crowdsec/pkg/hubops"
	"github.com/crowdsecurity/crowdsec/cmd/crowdsec-cli/args"
	"github.com/crowdsecurity/crowdsec/cmd/crowdsec-cli/clisetup/setup"
	"github.com/crowdsecurity/crowdsec/cmd/crowdsec-cli/require"
)

func isGeneratedYAML(input io.Reader) (bool, error) {
	decoder := yaml.NewDecoder(input)

	for {
		var node yaml.Node
		err := decoder.Decode(&node)
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			return false, err
		}

		// Skip documents that are empty or contain only comments
		if isEmptyYAMLDoc(&node) {
			continue
		}

		// XXX: TODO: legacy wizard??
		// XXX: TODO: checksum wizard??
		// XXX: TODO: which string?
		if !strings.Contains(strings.ToLower(node.HeadComment), "generated") {
			return false, nil
		}
	}

	return true, nil
}

func isEmptyYAMLDoc(node *yaml.Node) bool {
	// Consider it empty if there's no content
	if node.Kind == 0 || (node.Kind == yaml.DocumentNode && len(node.Content) == 0) {
		return true
	}

	// Consider it empty if itâ€™s an empty mapping or sequence
	if node.Kind == yaml.DocumentNode && len(node.Content) == 1 {
		c := node.Content[0]
		if (c.Kind == yaml.MappingNode || c.Kind == yaml.SequenceNode) && len(c.Content) == 0 {
			return true
		}
	}

	return false
}

func filterGeneratedAcquis(acquisFiles []string) ([]string, error) {
	ret := []string{}

	for _, fileName := range acquisFiles {
		file, err := os.Open(fileName)
		if err != nil {
			return nil, err
		}

		isGenerated, err := isGeneratedYAML(file)
		if err != nil {
			file.Close()
			return nil, err
		}

		file.Close()

		if !isGenerated {
			ret = append(ret, fileName)
		}
	}

	return ret, nil
}

func (cli *cliSetup) interactive(ctx context.Context, f detectFlags, interactive bool) error {
	cfg := cli.cfg()

	if err := require.Agent(cfg); err != nil {
		return err
	}

	userAcquisFiles, err := filterGeneratedAcquis(cfg.Crowdsec.AcquisitionFiles)
	if err != nil {
		return err
	}

	if len(userAcquisFiles) != 0 {
		fmt.Fprintln(os.Stdout, "The following acquisition files were not generated by crowdsec, or were altered:")

		for _, f := range userAcquisFiles {
			fmt.Fprintln(os.Stdout, " - " + f)
		}

		if !interactive {
			fmt.Fprintln(os.Stdout, "The automatic setup will not proceed to avoid any conflict with the above files. To add new services, run 'cscli setup' in a shell.")
			return nil
		}

		fmt.Fprintln(os.Stdout)
		fmt.Fprintln(os.Stdout, "After the setup, make sure that these files don't conflict with the new acquisition configuration. In particular, don't parse the same log files multiple times.")
		fmt.Fprintln(os.Stdout)
	}

	// XXX: TODO: review all prompts, cli help, examples, etc.

	// XXX: TODO: agent configuration vs lapi?
	// what if agent is disabled?
	
	// XXX: TODO: reuse or re-implement part of LoadAcquisition to collect the list of acquisition files
	// then we to process them to see whether they are auto-generated or not
	// scan all document, discard empty
	// check for comments inside

	// XXX: TODO: if some acquisition is already defined:
	//   interactive == false -> skip detect+install
	//   interactive == true -> change messages/prompt?

	detect := true
	if interactive {
		prompt := survey.Confirm{
			Message: "Detect and configure services?",
			Default: true,
		}

		if err := survey.AskOne(&prompt, &detect); err != nil {
			return err
		}
	}

	fmt.Fprintln(os.Stdout)

	if !detect {
		fmt.Println("Quitting crowdsec configuration.")
		fmt.Println("You can always run 'crowdsec setup' later.")
		return nil
	}

	defaultServiceDetect := csconfig.DefaultConfigPath("detect.yaml")

	detectReader, err := os.Open(defaultServiceDetect)
	if err != nil {
		return err
	}

	detector, err := setup.NewDetector(detectReader)
	if err != nil {
		return err
	}

	logger := logrus.StandardLogger()

	stup, err := setup.NewSetup(detector, f.toDetectOptions(logger), logger)
	if err != nil {
		return err
	}

	svcDetected := stup.DetectedServices()

	switch {
	case len(svcDetected) == 0:
		fmt.Fprintln(os.Stdout, "No services detected.")
		return nil
	case interactive:
		svcSelected := []string{}

		prompt := &survey.MultiSelect{
			Message: "Please confirm the services to configure. Excluding them will skip the related scenarios and log acquisition.\n",
			Options: svcDetected,
			Default: svcDetected,
		}

		err := survey.AskOne(prompt, &svcSelected)
		if err != nil {
			return err
		}

		svcFiltered := []setup.ServicePlan{}
		for _, svc := range stup.Plans {
			if slices.Contains(svcSelected, svc.Name) {
				svcFiltered = append(svcFiltered, svc)
			}
		}

		stup.Plans = svcFiltered
	default:
		fmt.Println("The following services will be configured:")
		for _, svc := range svcDetected {
			fmt.Printf("- %s\n", svc)
		}
	}

	fmt.Fprintln(os.Stdout)

	hubSpecs := stup.CollectHubSpecs()

	if len(hubSpecs) > 0 {
		if err = cli.install(ctx, interactive, false, hubSpecs); err != nil {
			return err
		}

		fmt.Fprintln(os.Stdout)
	}

	acquisitionSpecs := stup.CollectAcquisitionSpecs()

	if len(acquisitionSpecs) > 0 {
		installAcquis := true
		if interactive {
			prompt := survey.Confirm{
				Message: "Generate acquisition configuration?",
				Default: true,
			}
	
			if err := survey.AskOne(&prompt, &installAcquis); err != nil {
				return err
			}
		}

		// XXX TODO: warn user not to alter the generated files
		// XXX TODO: and they are responsible to remove them and
		// the collections when removing the associated software
		if installAcquis {
			acquisDir := cli.cfg().Crowdsec.AcquisitionDirPath
			if err := cli.acquisition(acquisitionSpecs, acquisDir); err != nil {
				return err
			}
		}
	}

	return nil
}

func (cli *cliSetup) newInteractiveCmd() *cobra.Command {
	f := detectFlags{}
	var auto bool

	cmd := &cobra.Command{
		Use:               "interactive",
		// XXX: TODO: better description
		Short:             "Tools to configure crowdsec",
		Long:              "Manage hub configuration and service detection",
		DisableAutoGenTag: true,
		Args:              args.NoArgs,
		// XXX: TODO: examples!
		RunE: func(cmd *cobra.Command, _ []string) error {
			err := cli.interactive(cmd.Context(), f, !auto)
			if  errors.Is(err, hubops.ErrUserCanceled) {
				fmt.Fprintln(os.Stdout, err.Error())
				fmt.Println("You can always run 'crowdsec setup' later.")
				return nil
			}

			return err
		},
	}

	f.bind(cmd)

	flags := cmd.Flags()
	flags.BoolVar(&auto, "auto", false, "Unattended setup -- automatically detect services and generate configuration")

	return cmd
}

func maybeStdinFile(path string) (*os.File, error) {
	if path == "-" {
		return os.Stdin, nil
	}

	reader, err := os.Open(path)
	if err != nil {
		return nil, err
	}

	return reader, nil
}
