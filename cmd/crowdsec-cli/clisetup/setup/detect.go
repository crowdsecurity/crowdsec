package setup

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"

	"github.com/blackfireio/osinfo"
	"github.com/crowdsecurity/crowdsec/pkg/acquisition"
	"github.com/crowdsecurity/crowdsec/pkg/acquisition/configuration"
	"github.com/expr-lang/expr"
	"github.com/expr-lang/expr/vm"
	goccyyaml "github.com/goccy/go-yaml"
	"github.com/sirupsen/logrus"
	"gopkg.in/yaml.v3"
	"slices"
)

// HubSpec contains the items (mostly collections) that are recommended to support a service.
type HubSpec map[string][]string

var (
	ErrEmptyDatasourceConfig      = errors.New("datasource configuration is empty")
	ErrMissingAcquisitionFilename = errors.New("a filename for the datasource configuration is mandatory")
)

type DatasourceConfig map[string]any

// Validate checks if the DataSourceItem represents a valid configuration for an acquisition.DataSource.
func (d DatasourceConfig) Validate() error {
	if len(d) == 0 {
		return ErrEmptyDatasourceConfig
	}

	// formally validate YAML

	commonDS := configuration.DataSourceCommonCfg{}

	body, err := yaml.Marshal(d)
	if err != nil {
		return err
	}

	err = yaml.Unmarshal(body, &commonDS)
	if err != nil {
		return err
	}

	if commonDS.Source == "" {
		return errors.New("source is empty")
	}

	// source must be known

	ds, err := acquisition.GetDataSourceIface(commonDS.Source)
	if err != nil {
		return err
	}

	// unmarshal and validate the rest with the specific implementation

	err = ds.UnmarshalConfig(body)
	if err != nil {
		return err
	}

	return nil
}

// Acquisition contains the datasource configuration to support a detected service.
type AcquisitionSpec struct {
	Filename   string
	Datasource DatasourceConfig
}

func (a *AcquisitionSpec) Path(toDir string) (string, error) {
	if a.Filename == "" {
		return "", errors.New("empty acquisition filename")
	}

	return filepath.Join(toDir, "setup."+a.Filename), nil
}

func (a *AcquisitionSpec) ToYAML() ([]byte, error) {
	out, err := goccyyaml.MarshalWithOptions(a.Datasource, goccyyaml.IndentSequence(true))
	if err != nil {
		return nil, fmt.Errorf("while encoding datasource: %w", err)
	}

	return out, nil
}

func (a *AcquisitionSpec) WriteTo(toDir string) error {
	path, err := a.Path(toDir)
	if err != nil {
		return err
	}

	if err := os.MkdirAll(toDir, 0o700); err != nil {
		return fmt.Errorf("creating acquisition directory: %w", err)
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("creating acquisition file: %w", err)
	}
	defer f.Close()

	_, err = f.WriteString(`#
# Configuration generated by "cscli setup".
# Please check your non-generated configuration files to make sure
# the log sources are not acquired twice. This includes
# the file acquis.yaml created by crowdsec <= 1.6.9.
#
`)
	if err != nil {
		return fmt.Errorf("while writing to %s: %w", path, err)
	}

	content, err := a.ToYAML()
	if err != nil {
		return err
	}

	hash := sha256.Sum256(content)
	checksum := hex.EncodeToString(hash[:])

	_, err = f.WriteString("# cscli-checksum: " + checksum + "\n\n")
	if err != nil {
		return fmt.Errorf("while writing to %s: %w", path, err)
	}

	_, err = f.Write(content)
	if err != nil {
		return fmt.Errorf("while writing to %s: %w", path, err)
	}

	if err = f.Sync(); err != nil {
		return fmt.Errorf("while syncing %s: %w", path, err)
	}

	return nil
}

type InstallRecommendation struct {
	HubSpec         HubSpec         `yaml:"install,omitempty"`
	AcquisitionSpec AcquisitionSpec `yaml:"acquisition,omitempty"`
}

// ServicePlan describes the actions to perform for a detected service.
type ServicePlan struct {
	Name                  string `yaml:"detected_service"`
	InstallRecommendation `yaml:",inline"`
}

// Setup is a container for a list of ServicePlan objects, allowing for future extensions.
type Setup struct {
	Plans []ServicePlan `yaml:"setup"`
}

func (s *Setup) CollectHubSpecs() []HubSpec {
	ret := []HubSpec{}

	for _, svc := range s.Plans {
		ret = append(ret, svc.HubSpec)
	}

	return ret
}

func (s *Setup) CollectAcquisitionSpecs() []AcquisitionSpec {
	ret := make([]AcquisitionSpec, len(s.Plans))

	for idx, svc := range s.Plans {
		// XXX: assume no filename conflict
		ret[idx] = svc.AcquisitionSpec
	}

	return ret
}

func (s *Setup) DetectedServices() []string {
	ret := make([]string, 0, len(s.Plans))

	for _, svc := range s.Plans {
		ret = append(ret, svc.Name)
	}

	slices.Sort(ret)

	return ret
}

func (s *Setup) ToYAML(outYaml bool) ([]byte, error) {
	var (
		ret []byte
		err error
	)

	buf := &bytes.Buffer{}
	enc := yaml.NewEncoder(buf)
	enc.SetIndent(2)

	if err = enc.Encode(s); err != nil {
		return nil, err
	}

	if err = enc.Close(); err != nil {
		return nil, err
	}

	ret = buf.Bytes()

	if !outYaml {
		// take a general approach to output json, so we avoid the
		// double tags in the structures and can use go-yaml features
		// missing from the json package
		ret, err = goccyyaml.YAMLToJSON(ret)
		if err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// Detector is generated from the detection rules (detect.yaml) and can generate the setup plan.
type Detector struct {
	Version string                  `yaml:"version"`
	Detect  map[string]ServiceRules `yaml:"detect"`
}

func NewDetector(detectReader io.Reader) (*Detector, error) {
	d := Detector{}

	yamlBytes, err := io.ReadAll(detectReader)
	if err != nil {
		return nil, err
	}

	dec := yaml.NewDecoder(bytes.NewBuffer(yamlBytes))
	dec.KnownFields(true)

	if err = dec.Decode(&d); err != nil {
		return nil, err
	}

	switch d.Version {
	case "":
		return nil, errors.New("missing version tag (must be 1.0)")
	case "1.0":
		// all is well
	default:
		return nil, fmt.Errorf("invalid version tag '%s' (must be 1.0)", d.Version)
	}

	for name := range d.Detect {
		svc := d.Detect[name]
		if err := svc.Compile(); err != nil {
			return nil, fmt.Errorf("%q: %w", name, err)
		}

		d.Detect[name] = svc // reassign to ensure the compiled rules are stored
	}

	for name, svc := range d.Detect {
		if svc.AcquisitionSpec.Filename == "" {
			if len(svc.AcquisitionSpec.Datasource) == 0 {
				// missing acquisition is ok - only hub items
				continue
			}

			// if a datasource is specified, we must have a filename
			return nil, fmt.Errorf("invalid acquisition spec for %s: %w", name, ErrMissingAcquisitionFilename)
		}

		// but empty datasource config is not ok
		if err := svc.AcquisitionSpec.Datasource.Validate(); err != nil {
			return nil, fmt.Errorf("invalid acquisition spec for %s: %w", name, err)
		}
	}

	return &d, nil
}

// ListSupportedServices returns a list of the services recognized by the detector.
func (d *Detector) ListSupportedServices() []string {
	keys := make([]string, 0)
	for k := range d.Detect {
		keys = append(keys, k)
	}

	sort.Strings(keys)

	return keys
}

func DetectOS(forcedOS ExprOS, logger *logrus.Logger) (ExprOS, error) {
	if forcedOS != (ExprOS{}) {
		logger.Debugf("Forced OS - %+v", forcedOS)
		return forcedOS, nil
	}

	osfull, err := osinfo.GetOSInfo()
	if err != nil {
		return ExprOS{}, fmt.Errorf("detecting OS: %w", err)
	}

	logger.Debugf("Detected OS - %+v", *osfull)

	return ExprOS{
		Family:     osfull.Family,
		ID:         osfull.ID,
		RawVersion: osfull.Version,
	}, nil
}

// ServiceRules describes the rules for detecting a service and its recommended items.
type ServiceRules struct {
	When                  []string `yaml:"when"`
	compiledWhen          []*vm.Program
	InstallRecommendation `yaml:",inline"`
}

func (s *ServiceRules) Compile() error {
	s.compiledWhen = make([]*vm.Program, len(s.When))
	for i, rule := range s.When {
		// pass an empty environment struct so the compiler can know the types
		compiled, err := expr.Compile(rule, expr.WithContext("Ctx"), expr.Env(&ExprEnvironment{}))
		if err != nil {
			return fmt.Errorf("compiling rule %q: %w", rule, err)
		}

		s.compiledWhen[i] = compiled
	}

	return nil
}

func (s *ServiceRules) Evaluate(env *ExprEnvironment, logger *logrus.Logger) (bool, error) {
	match := true

	if len(s.compiledWhen) != len(s.When) {
		return false, errors.New("rules not compiled, call Compile() first")
	}

	for _, rule := range s.compiledWhen {
		out, err := expr.Run(rule, env)
		logger.Debugf("  Rule %q -> %t, %v", rule.Source(), out, err)

		if err != nil {
			return false, fmt.Errorf("rule %q: %w", rule.Source(), err)
		}

		outbool, ok := out.(bool)
		if !ok {
			return false, fmt.Errorf("rule %q: type must be a boolean", rule.Source())
		}

		match = match && outbool
		// keep evaluating, to detect possible expression errors
	}

	return match, nil
}

// DetectOptions contains parameters for the Detect function.
type DetectOptions struct {
	// slice of unit names that we want to force-detect
	ForcedUnits []string
	// slice of process names that we want to force-detect
	ForcedProcesses []string
	ForcedOS        ExprOS
	SkipServices    []string
	SkipSystemd     bool
}
