// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/crowdsecurity/crowdsec/pkg/database/ent/alert"
	"github.com/crowdsecurity/crowdsec/pkg/database/ent/blocker"
	"github.com/crowdsecurity/crowdsec/pkg/database/ent/decision"
	"github.com/crowdsecurity/crowdsec/pkg/database/ent/event"
	"github.com/crowdsecurity/crowdsec/pkg/database/ent/machine"
	"github.com/crowdsecurity/crowdsec/pkg/database/ent/meta"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlert    = "Alert"
	TypeBlocker  = "Blocker"
	TypeDecision = "Decision"
	TypeEvent    = "Event"
	TypeMachine  = "Machine"
	TypeMeta     = "Meta"
)

// AlertMutation represents an operation that mutate the Alerts
// nodes in the graph.
type AlertMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	scenario           *string
	bucketId           *string
	message            *string
	eventsCount        *int32
	addeventsCount     *int32
	startedAt          *time.Time
	stoppedAt          *time.Time
	sourceIp           *string
	sourceRange        *string
	sourceAsNumber     *string
	sourceAsName       *string
	sourceCountry      *string
	sourceLatitude     *float32
	addsourceLatitude  *float32
	sourceLongitude    *float32
	addsourceLongitude *float32
	sourceScope        *string
	sourceValue        *string
	capacity           *int32
	addcapacity        *int32
	leakSpeed          *string
	clearedFields      map[string]struct{}
	owner              *int
	clearedowner       bool
	decisions          map[int]struct{}
	removeddecisions   map[int]struct{}
	events             map[int]struct{}
	removedevents      map[int]struct{}
	metas              map[int]struct{}
	removedmetas       map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Alert, error)
}

var _ ent.Mutation = (*AlertMutation)(nil)

// alertOption allows to manage the mutation configuration using functional options.
type alertOption func(*AlertMutation)

// newAlertMutation creates new mutation for $n.Name.
func newAlertMutation(c config, op Op, opts ...alertOption) *AlertMutation {
	m := &AlertMutation{
		config:        c,
		op:            op,
		typ:           TypeAlert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertID sets the id field of the mutation.
func withAlertID(id int) alertOption {
	return func(m *AlertMutation) {
		var (
			err   error
			once  sync.Once
			value *Alert
		)
		m.oldValue = func(ctx context.Context) (*Alert, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Alert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlert sets the old Alert of the mutation.
func withAlert(node *Alert) alertOption {
	return func(m *AlertMutation) {
		m.oldValue = func(context.Context) (*Alert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AlertMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *AlertMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *AlertMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *AlertMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *AlertMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *AlertMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *AlertMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetScenario sets the scenario field.
func (m *AlertMutation) SetScenario(s string) {
	m.scenario = &s
}

// Scenario returns the scenario value in the mutation.
func (m *AlertMutation) Scenario() (r string, exists bool) {
	v := m.scenario
	if v == nil {
		return
	}
	return *v, true
}

// OldScenario returns the old scenario value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldScenario(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScenario is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScenario requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenario: %w", err)
	}
	return oldValue.Scenario, nil
}

// ResetScenario reset all changes of the "scenario" field.
func (m *AlertMutation) ResetScenario() {
	m.scenario = nil
}

// SetBucketId sets the bucketId field.
func (m *AlertMutation) SetBucketId(s string) {
	m.bucketId = &s
}

// BucketId returns the bucketId value in the mutation.
func (m *AlertMutation) BucketId() (r string, exists bool) {
	v := m.bucketId
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketId returns the old bucketId value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldBucketId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBucketId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBucketId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketId: %w", err)
	}
	return oldValue.BucketId, nil
}

// ClearBucketId clears the value of bucketId.
func (m *AlertMutation) ClearBucketId() {
	m.bucketId = nil
	m.clearedFields[alert.FieldBucketId] = struct{}{}
}

// BucketIdCleared returns if the field bucketId was cleared in this mutation.
func (m *AlertMutation) BucketIdCleared() bool {
	_, ok := m.clearedFields[alert.FieldBucketId]
	return ok
}

// ResetBucketId reset all changes of the "bucketId" field.
func (m *AlertMutation) ResetBucketId() {
	m.bucketId = nil
	delete(m.clearedFields, alert.FieldBucketId)
}

// SetMessage sets the message field.
func (m *AlertMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the message value in the mutation.
func (m *AlertMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old message value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessage is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of message.
func (m *AlertMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[alert.FieldMessage] = struct{}{}
}

// MessageCleared returns if the field message was cleared in this mutation.
func (m *AlertMutation) MessageCleared() bool {
	_, ok := m.clearedFields[alert.FieldMessage]
	return ok
}

// ResetMessage reset all changes of the "message" field.
func (m *AlertMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, alert.FieldMessage)
}

// SetEventsCount sets the eventsCount field.
func (m *AlertMutation) SetEventsCount(i int32) {
	m.eventsCount = &i
	m.addeventsCount = nil
}

// EventsCount returns the eventsCount value in the mutation.
func (m *AlertMutation) EventsCount() (r int32, exists bool) {
	v := m.eventsCount
	if v == nil {
		return
	}
	return *v, true
}

// OldEventsCount returns the old eventsCount value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldEventsCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEventsCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEventsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventsCount: %w", err)
	}
	return oldValue.EventsCount, nil
}

// AddEventsCount adds i to eventsCount.
func (m *AlertMutation) AddEventsCount(i int32) {
	if m.addeventsCount != nil {
		*m.addeventsCount += i
	} else {
		m.addeventsCount = &i
	}
}

// AddedEventsCount returns the value that was added to the eventsCount field in this mutation.
func (m *AlertMutation) AddedEventsCount() (r int32, exists bool) {
	v := m.addeventsCount
	if v == nil {
		return
	}
	return *v, true
}

// ClearEventsCount clears the value of eventsCount.
func (m *AlertMutation) ClearEventsCount() {
	m.eventsCount = nil
	m.addeventsCount = nil
	m.clearedFields[alert.FieldEventsCount] = struct{}{}
}

// EventsCountCleared returns if the field eventsCount was cleared in this mutation.
func (m *AlertMutation) EventsCountCleared() bool {
	_, ok := m.clearedFields[alert.FieldEventsCount]
	return ok
}

// ResetEventsCount reset all changes of the "eventsCount" field.
func (m *AlertMutation) ResetEventsCount() {
	m.eventsCount = nil
	m.addeventsCount = nil
	delete(m.clearedFields, alert.FieldEventsCount)
}

// SetStartedAt sets the startedAt field.
func (m *AlertMutation) SetStartedAt(t time.Time) {
	m.startedAt = &t
}

// StartedAt returns the startedAt value in the mutation.
func (m *AlertMutation) StartedAt() (r time.Time, exists bool) {
	v := m.startedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old startedAt value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of startedAt.
func (m *AlertMutation) ClearStartedAt() {
	m.startedAt = nil
	m.clearedFields[alert.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the field startedAt was cleared in this mutation.
func (m *AlertMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[alert.FieldStartedAt]
	return ok
}

// ResetStartedAt reset all changes of the "startedAt" field.
func (m *AlertMutation) ResetStartedAt() {
	m.startedAt = nil
	delete(m.clearedFields, alert.FieldStartedAt)
}

// SetStoppedAt sets the stoppedAt field.
func (m *AlertMutation) SetStoppedAt(t time.Time) {
	m.stoppedAt = &t
}

// StoppedAt returns the stoppedAt value in the mutation.
func (m *AlertMutation) StoppedAt() (r time.Time, exists bool) {
	v := m.stoppedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldStoppedAt returns the old stoppedAt value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldStoppedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStoppedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStoppedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoppedAt: %w", err)
	}
	return oldValue.StoppedAt, nil
}

// ClearStoppedAt clears the value of stoppedAt.
func (m *AlertMutation) ClearStoppedAt() {
	m.stoppedAt = nil
	m.clearedFields[alert.FieldStoppedAt] = struct{}{}
}

// StoppedAtCleared returns if the field stoppedAt was cleared in this mutation.
func (m *AlertMutation) StoppedAtCleared() bool {
	_, ok := m.clearedFields[alert.FieldStoppedAt]
	return ok
}

// ResetStoppedAt reset all changes of the "stoppedAt" field.
func (m *AlertMutation) ResetStoppedAt() {
	m.stoppedAt = nil
	delete(m.clearedFields, alert.FieldStoppedAt)
}

// SetSourceIp sets the sourceIp field.
func (m *AlertMutation) SetSourceIp(s string) {
	m.sourceIp = &s
}

// SourceIp returns the sourceIp value in the mutation.
func (m *AlertMutation) SourceIp() (r string, exists bool) {
	v := m.sourceIp
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceIp returns the old sourceIp value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldSourceIp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceIp is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceIp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceIp: %w", err)
	}
	return oldValue.SourceIp, nil
}

// ClearSourceIp clears the value of sourceIp.
func (m *AlertMutation) ClearSourceIp() {
	m.sourceIp = nil
	m.clearedFields[alert.FieldSourceIp] = struct{}{}
}

// SourceIpCleared returns if the field sourceIp was cleared in this mutation.
func (m *AlertMutation) SourceIpCleared() bool {
	_, ok := m.clearedFields[alert.FieldSourceIp]
	return ok
}

// ResetSourceIp reset all changes of the "sourceIp" field.
func (m *AlertMutation) ResetSourceIp() {
	m.sourceIp = nil
	delete(m.clearedFields, alert.FieldSourceIp)
}

// SetSourceRange sets the sourceRange field.
func (m *AlertMutation) SetSourceRange(s string) {
	m.sourceRange = &s
}

// SourceRange returns the sourceRange value in the mutation.
func (m *AlertMutation) SourceRange() (r string, exists bool) {
	v := m.sourceRange
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceRange returns the old sourceRange value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldSourceRange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceRange is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceRange: %w", err)
	}
	return oldValue.SourceRange, nil
}

// ClearSourceRange clears the value of sourceRange.
func (m *AlertMutation) ClearSourceRange() {
	m.sourceRange = nil
	m.clearedFields[alert.FieldSourceRange] = struct{}{}
}

// SourceRangeCleared returns if the field sourceRange was cleared in this mutation.
func (m *AlertMutation) SourceRangeCleared() bool {
	_, ok := m.clearedFields[alert.FieldSourceRange]
	return ok
}

// ResetSourceRange reset all changes of the "sourceRange" field.
func (m *AlertMutation) ResetSourceRange() {
	m.sourceRange = nil
	delete(m.clearedFields, alert.FieldSourceRange)
}

// SetSourceAsNumber sets the sourceAsNumber field.
func (m *AlertMutation) SetSourceAsNumber(s string) {
	m.sourceAsNumber = &s
}

// SourceAsNumber returns the sourceAsNumber value in the mutation.
func (m *AlertMutation) SourceAsNumber() (r string, exists bool) {
	v := m.sourceAsNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceAsNumber returns the old sourceAsNumber value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldSourceAsNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceAsNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceAsNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceAsNumber: %w", err)
	}
	return oldValue.SourceAsNumber, nil
}

// ClearSourceAsNumber clears the value of sourceAsNumber.
func (m *AlertMutation) ClearSourceAsNumber() {
	m.sourceAsNumber = nil
	m.clearedFields[alert.FieldSourceAsNumber] = struct{}{}
}

// SourceAsNumberCleared returns if the field sourceAsNumber was cleared in this mutation.
func (m *AlertMutation) SourceAsNumberCleared() bool {
	_, ok := m.clearedFields[alert.FieldSourceAsNumber]
	return ok
}

// ResetSourceAsNumber reset all changes of the "sourceAsNumber" field.
func (m *AlertMutation) ResetSourceAsNumber() {
	m.sourceAsNumber = nil
	delete(m.clearedFields, alert.FieldSourceAsNumber)
}

// SetSourceAsName sets the sourceAsName field.
func (m *AlertMutation) SetSourceAsName(s string) {
	m.sourceAsName = &s
}

// SourceAsName returns the sourceAsName value in the mutation.
func (m *AlertMutation) SourceAsName() (r string, exists bool) {
	v := m.sourceAsName
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceAsName returns the old sourceAsName value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldSourceAsName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceAsName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceAsName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceAsName: %w", err)
	}
	return oldValue.SourceAsName, nil
}

// ClearSourceAsName clears the value of sourceAsName.
func (m *AlertMutation) ClearSourceAsName() {
	m.sourceAsName = nil
	m.clearedFields[alert.FieldSourceAsName] = struct{}{}
}

// SourceAsNameCleared returns if the field sourceAsName was cleared in this mutation.
func (m *AlertMutation) SourceAsNameCleared() bool {
	_, ok := m.clearedFields[alert.FieldSourceAsName]
	return ok
}

// ResetSourceAsName reset all changes of the "sourceAsName" field.
func (m *AlertMutation) ResetSourceAsName() {
	m.sourceAsName = nil
	delete(m.clearedFields, alert.FieldSourceAsName)
}

// SetSourceCountry sets the sourceCountry field.
func (m *AlertMutation) SetSourceCountry(s string) {
	m.sourceCountry = &s
}

// SourceCountry returns the sourceCountry value in the mutation.
func (m *AlertMutation) SourceCountry() (r string, exists bool) {
	v := m.sourceCountry
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceCountry returns the old sourceCountry value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldSourceCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceCountry is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceCountry: %w", err)
	}
	return oldValue.SourceCountry, nil
}

// ClearSourceCountry clears the value of sourceCountry.
func (m *AlertMutation) ClearSourceCountry() {
	m.sourceCountry = nil
	m.clearedFields[alert.FieldSourceCountry] = struct{}{}
}

// SourceCountryCleared returns if the field sourceCountry was cleared in this mutation.
func (m *AlertMutation) SourceCountryCleared() bool {
	_, ok := m.clearedFields[alert.FieldSourceCountry]
	return ok
}

// ResetSourceCountry reset all changes of the "sourceCountry" field.
func (m *AlertMutation) ResetSourceCountry() {
	m.sourceCountry = nil
	delete(m.clearedFields, alert.FieldSourceCountry)
}

// SetSourceLatitude sets the sourceLatitude field.
func (m *AlertMutation) SetSourceLatitude(f float32) {
	m.sourceLatitude = &f
	m.addsourceLatitude = nil
}

// SourceLatitude returns the sourceLatitude value in the mutation.
func (m *AlertMutation) SourceLatitude() (r float32, exists bool) {
	v := m.sourceLatitude
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceLatitude returns the old sourceLatitude value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldSourceLatitude(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceLatitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceLatitude: %w", err)
	}
	return oldValue.SourceLatitude, nil
}

// AddSourceLatitude adds f to sourceLatitude.
func (m *AlertMutation) AddSourceLatitude(f float32) {
	if m.addsourceLatitude != nil {
		*m.addsourceLatitude += f
	} else {
		m.addsourceLatitude = &f
	}
}

// AddedSourceLatitude returns the value that was added to the sourceLatitude field in this mutation.
func (m *AlertMutation) AddedSourceLatitude() (r float32, exists bool) {
	v := m.addsourceLatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearSourceLatitude clears the value of sourceLatitude.
func (m *AlertMutation) ClearSourceLatitude() {
	m.sourceLatitude = nil
	m.addsourceLatitude = nil
	m.clearedFields[alert.FieldSourceLatitude] = struct{}{}
}

// SourceLatitudeCleared returns if the field sourceLatitude was cleared in this mutation.
func (m *AlertMutation) SourceLatitudeCleared() bool {
	_, ok := m.clearedFields[alert.FieldSourceLatitude]
	return ok
}

// ResetSourceLatitude reset all changes of the "sourceLatitude" field.
func (m *AlertMutation) ResetSourceLatitude() {
	m.sourceLatitude = nil
	m.addsourceLatitude = nil
	delete(m.clearedFields, alert.FieldSourceLatitude)
}

// SetSourceLongitude sets the sourceLongitude field.
func (m *AlertMutation) SetSourceLongitude(f float32) {
	m.sourceLongitude = &f
	m.addsourceLongitude = nil
}

// SourceLongitude returns the sourceLongitude value in the mutation.
func (m *AlertMutation) SourceLongitude() (r float32, exists bool) {
	v := m.sourceLongitude
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceLongitude returns the old sourceLongitude value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldSourceLongitude(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceLongitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceLongitude: %w", err)
	}
	return oldValue.SourceLongitude, nil
}

// AddSourceLongitude adds f to sourceLongitude.
func (m *AlertMutation) AddSourceLongitude(f float32) {
	if m.addsourceLongitude != nil {
		*m.addsourceLongitude += f
	} else {
		m.addsourceLongitude = &f
	}
}

// AddedSourceLongitude returns the value that was added to the sourceLongitude field in this mutation.
func (m *AlertMutation) AddedSourceLongitude() (r float32, exists bool) {
	v := m.addsourceLongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearSourceLongitude clears the value of sourceLongitude.
func (m *AlertMutation) ClearSourceLongitude() {
	m.sourceLongitude = nil
	m.addsourceLongitude = nil
	m.clearedFields[alert.FieldSourceLongitude] = struct{}{}
}

// SourceLongitudeCleared returns if the field sourceLongitude was cleared in this mutation.
func (m *AlertMutation) SourceLongitudeCleared() bool {
	_, ok := m.clearedFields[alert.FieldSourceLongitude]
	return ok
}

// ResetSourceLongitude reset all changes of the "sourceLongitude" field.
func (m *AlertMutation) ResetSourceLongitude() {
	m.sourceLongitude = nil
	m.addsourceLongitude = nil
	delete(m.clearedFields, alert.FieldSourceLongitude)
}

// SetSourceScope sets the sourceScope field.
func (m *AlertMutation) SetSourceScope(s string) {
	m.sourceScope = &s
}

// SourceScope returns the sourceScope value in the mutation.
func (m *AlertMutation) SourceScope() (r string, exists bool) {
	v := m.sourceScope
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceScope returns the old sourceScope value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldSourceScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceScope is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceScope: %w", err)
	}
	return oldValue.SourceScope, nil
}

// ClearSourceScope clears the value of sourceScope.
func (m *AlertMutation) ClearSourceScope() {
	m.sourceScope = nil
	m.clearedFields[alert.FieldSourceScope] = struct{}{}
}

// SourceScopeCleared returns if the field sourceScope was cleared in this mutation.
func (m *AlertMutation) SourceScopeCleared() bool {
	_, ok := m.clearedFields[alert.FieldSourceScope]
	return ok
}

// ResetSourceScope reset all changes of the "sourceScope" field.
func (m *AlertMutation) ResetSourceScope() {
	m.sourceScope = nil
	delete(m.clearedFields, alert.FieldSourceScope)
}

// SetSourceValue sets the sourceValue field.
func (m *AlertMutation) SetSourceValue(s string) {
	m.sourceValue = &s
}

// SourceValue returns the sourceValue value in the mutation.
func (m *AlertMutation) SourceValue() (r string, exists bool) {
	v := m.sourceValue
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceValue returns the old sourceValue value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldSourceValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceValue is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceValue: %w", err)
	}
	return oldValue.SourceValue, nil
}

// ClearSourceValue clears the value of sourceValue.
func (m *AlertMutation) ClearSourceValue() {
	m.sourceValue = nil
	m.clearedFields[alert.FieldSourceValue] = struct{}{}
}

// SourceValueCleared returns if the field sourceValue was cleared in this mutation.
func (m *AlertMutation) SourceValueCleared() bool {
	_, ok := m.clearedFields[alert.FieldSourceValue]
	return ok
}

// ResetSourceValue reset all changes of the "sourceValue" field.
func (m *AlertMutation) ResetSourceValue() {
	m.sourceValue = nil
	delete(m.clearedFields, alert.FieldSourceValue)
}

// SetCapacity sets the capacity field.
func (m *AlertMutation) SetCapacity(i int32) {
	m.capacity = &i
	m.addcapacity = nil
}

// Capacity returns the capacity value in the mutation.
func (m *AlertMutation) Capacity() (r int32, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old capacity value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldCapacity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCapacity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds i to capacity.
func (m *AlertMutation) AddCapacity(i int32) {
	if m.addcapacity != nil {
		*m.addcapacity += i
	} else {
		m.addcapacity = &i
	}
}

// AddedCapacity returns the value that was added to the capacity field in this mutation.
func (m *AlertMutation) AddedCapacity() (r int32, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearCapacity clears the value of capacity.
func (m *AlertMutation) ClearCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	m.clearedFields[alert.FieldCapacity] = struct{}{}
}

// CapacityCleared returns if the field capacity was cleared in this mutation.
func (m *AlertMutation) CapacityCleared() bool {
	_, ok := m.clearedFields[alert.FieldCapacity]
	return ok
}

// ResetCapacity reset all changes of the "capacity" field.
func (m *AlertMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	delete(m.clearedFields, alert.FieldCapacity)
}

// SetLeakSpeed sets the leakSpeed field.
func (m *AlertMutation) SetLeakSpeed(s string) {
	m.leakSpeed = &s
}

// LeakSpeed returns the leakSpeed value in the mutation.
func (m *AlertMutation) LeakSpeed() (r string, exists bool) {
	v := m.leakSpeed
	if v == nil {
		return
	}
	return *v, true
}

// OldLeakSpeed returns the old leakSpeed value of the Alert.
// If the Alert object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlertMutation) OldLeakSpeed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLeakSpeed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLeakSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeakSpeed: %w", err)
	}
	return oldValue.LeakSpeed, nil
}

// ClearLeakSpeed clears the value of leakSpeed.
func (m *AlertMutation) ClearLeakSpeed() {
	m.leakSpeed = nil
	m.clearedFields[alert.FieldLeakSpeed] = struct{}{}
}

// LeakSpeedCleared returns if the field leakSpeed was cleared in this mutation.
func (m *AlertMutation) LeakSpeedCleared() bool {
	_, ok := m.clearedFields[alert.FieldLeakSpeed]
	return ok
}

// ResetLeakSpeed reset all changes of the "leakSpeed" field.
func (m *AlertMutation) ResetLeakSpeed() {
	m.leakSpeed = nil
	delete(m.clearedFields, alert.FieldLeakSpeed)
}

// SetOwnerID sets the owner edge to Machine by id.
func (m *AlertMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Machine.
func (m *AlertMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *AlertMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *AlertMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AlertMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *AlertMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddDecisionIDs adds the decisions edge to Decision by ids.
func (m *AlertMutation) AddDecisionIDs(ids ...int) {
	if m.decisions == nil {
		m.decisions = make(map[int]struct{})
	}
	for i := range ids {
		m.decisions[ids[i]] = struct{}{}
	}
}

// RemoveDecisionIDs removes the decisions edge to Decision by ids.
func (m *AlertMutation) RemoveDecisionIDs(ids ...int) {
	if m.removeddecisions == nil {
		m.removeddecisions = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddecisions[ids[i]] = struct{}{}
	}
}

// RemovedDecisions returns the removed ids of decisions.
func (m *AlertMutation) RemovedDecisionsIDs() (ids []int) {
	for id := range m.removeddecisions {
		ids = append(ids, id)
	}
	return
}

// DecisionsIDs returns the decisions ids in the mutation.
func (m *AlertMutation) DecisionsIDs() (ids []int) {
	for id := range m.decisions {
		ids = append(ids, id)
	}
	return
}

// ResetDecisions reset all changes of the "decisions" edge.
func (m *AlertMutation) ResetDecisions() {
	m.decisions = nil
	m.removeddecisions = nil
}

// AddEventIDs adds the events edge to Event by ids.
func (m *AlertMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// RemoveEventIDs removes the events edge to Event by ids.
func (m *AlertMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed ids of events.
func (m *AlertMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the events ids in the mutation.
func (m *AlertMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents reset all changes of the "events" edge.
func (m *AlertMutation) ResetEvents() {
	m.events = nil
	m.removedevents = nil
}

// AddMetaIDs adds the metas edge to Meta by ids.
func (m *AlertMutation) AddMetaIDs(ids ...int) {
	if m.metas == nil {
		m.metas = make(map[int]struct{})
	}
	for i := range ids {
		m.metas[ids[i]] = struct{}{}
	}
}

// RemoveMetaIDs removes the metas edge to Meta by ids.
func (m *AlertMutation) RemoveMetaIDs(ids ...int) {
	if m.removedmetas == nil {
		m.removedmetas = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmetas[ids[i]] = struct{}{}
	}
}

// RemovedMetas returns the removed ids of metas.
func (m *AlertMutation) RemovedMetasIDs() (ids []int) {
	for id := range m.removedmetas {
		ids = append(ids, id)
	}
	return
}

// MetasIDs returns the metas ids in the mutation.
func (m *AlertMutation) MetasIDs() (ids []int) {
	for id := range m.metas {
		ids = append(ids, id)
	}
	return
}

// ResetMetas reset all changes of the "metas" edge.
func (m *AlertMutation) ResetMetas() {
	m.metas = nil
	m.removedmetas = nil
}

// Op returns the operation name.
func (m *AlertMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Alert).
func (m *AlertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AlertMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, alert.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, alert.FieldUpdatedAt)
	}
	if m.scenario != nil {
		fields = append(fields, alert.FieldScenario)
	}
	if m.bucketId != nil {
		fields = append(fields, alert.FieldBucketId)
	}
	if m.message != nil {
		fields = append(fields, alert.FieldMessage)
	}
	if m.eventsCount != nil {
		fields = append(fields, alert.FieldEventsCount)
	}
	if m.startedAt != nil {
		fields = append(fields, alert.FieldStartedAt)
	}
	if m.stoppedAt != nil {
		fields = append(fields, alert.FieldStoppedAt)
	}
	if m.sourceIp != nil {
		fields = append(fields, alert.FieldSourceIp)
	}
	if m.sourceRange != nil {
		fields = append(fields, alert.FieldSourceRange)
	}
	if m.sourceAsNumber != nil {
		fields = append(fields, alert.FieldSourceAsNumber)
	}
	if m.sourceAsName != nil {
		fields = append(fields, alert.FieldSourceAsName)
	}
	if m.sourceCountry != nil {
		fields = append(fields, alert.FieldSourceCountry)
	}
	if m.sourceLatitude != nil {
		fields = append(fields, alert.FieldSourceLatitude)
	}
	if m.sourceLongitude != nil {
		fields = append(fields, alert.FieldSourceLongitude)
	}
	if m.sourceScope != nil {
		fields = append(fields, alert.FieldSourceScope)
	}
	if m.sourceValue != nil {
		fields = append(fields, alert.FieldSourceValue)
	}
	if m.capacity != nil {
		fields = append(fields, alert.FieldCapacity)
	}
	if m.leakSpeed != nil {
		fields = append(fields, alert.FieldLeakSpeed)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AlertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alert.FieldCreatedAt:
		return m.CreatedAt()
	case alert.FieldUpdatedAt:
		return m.UpdatedAt()
	case alert.FieldScenario:
		return m.Scenario()
	case alert.FieldBucketId:
		return m.BucketId()
	case alert.FieldMessage:
		return m.Message()
	case alert.FieldEventsCount:
		return m.EventsCount()
	case alert.FieldStartedAt:
		return m.StartedAt()
	case alert.FieldStoppedAt:
		return m.StoppedAt()
	case alert.FieldSourceIp:
		return m.SourceIp()
	case alert.FieldSourceRange:
		return m.SourceRange()
	case alert.FieldSourceAsNumber:
		return m.SourceAsNumber()
	case alert.FieldSourceAsName:
		return m.SourceAsName()
	case alert.FieldSourceCountry:
		return m.SourceCountry()
	case alert.FieldSourceLatitude:
		return m.SourceLatitude()
	case alert.FieldSourceLongitude:
		return m.SourceLongitude()
	case alert.FieldSourceScope:
		return m.SourceScope()
	case alert.FieldSourceValue:
		return m.SourceValue()
	case alert.FieldCapacity:
		return m.Capacity()
	case alert.FieldLeakSpeed:
		return m.LeakSpeed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AlertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alert.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case alert.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case alert.FieldScenario:
		return m.OldScenario(ctx)
	case alert.FieldBucketId:
		return m.OldBucketId(ctx)
	case alert.FieldMessage:
		return m.OldMessage(ctx)
	case alert.FieldEventsCount:
		return m.OldEventsCount(ctx)
	case alert.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case alert.FieldStoppedAt:
		return m.OldStoppedAt(ctx)
	case alert.FieldSourceIp:
		return m.OldSourceIp(ctx)
	case alert.FieldSourceRange:
		return m.OldSourceRange(ctx)
	case alert.FieldSourceAsNumber:
		return m.OldSourceAsNumber(ctx)
	case alert.FieldSourceAsName:
		return m.OldSourceAsName(ctx)
	case alert.FieldSourceCountry:
		return m.OldSourceCountry(ctx)
	case alert.FieldSourceLatitude:
		return m.OldSourceLatitude(ctx)
	case alert.FieldSourceLongitude:
		return m.OldSourceLongitude(ctx)
	case alert.FieldSourceScope:
		return m.OldSourceScope(ctx)
	case alert.FieldSourceValue:
		return m.OldSourceValue(ctx)
	case alert.FieldCapacity:
		return m.OldCapacity(ctx)
	case alert.FieldLeakSpeed:
		return m.OldLeakSpeed(ctx)
	}
	return nil, fmt.Errorf("unknown Alert field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AlertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alert.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case alert.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case alert.FieldScenario:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenario(v)
		return nil
	case alert.FieldBucketId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketId(v)
		return nil
	case alert.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case alert.FieldEventsCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventsCount(v)
		return nil
	case alert.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case alert.FieldStoppedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoppedAt(v)
		return nil
	case alert.FieldSourceIp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceIp(v)
		return nil
	case alert.FieldSourceRange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceRange(v)
		return nil
	case alert.FieldSourceAsNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceAsNumber(v)
		return nil
	case alert.FieldSourceAsName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceAsName(v)
		return nil
	case alert.FieldSourceCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceCountry(v)
		return nil
	case alert.FieldSourceLatitude:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceLatitude(v)
		return nil
	case alert.FieldSourceLongitude:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceLongitude(v)
		return nil
	case alert.FieldSourceScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceScope(v)
		return nil
	case alert.FieldSourceValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceValue(v)
		return nil
	case alert.FieldCapacity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case alert.FieldLeakSpeed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeakSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown Alert field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AlertMutation) AddedFields() []string {
	var fields []string
	if m.addeventsCount != nil {
		fields = append(fields, alert.FieldEventsCount)
	}
	if m.addsourceLatitude != nil {
		fields = append(fields, alert.FieldSourceLatitude)
	}
	if m.addsourceLongitude != nil {
		fields = append(fields, alert.FieldSourceLongitude)
	}
	if m.addcapacity != nil {
		fields = append(fields, alert.FieldCapacity)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AlertMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case alert.FieldEventsCount:
		return m.AddedEventsCount()
	case alert.FieldSourceLatitude:
		return m.AddedSourceLatitude()
	case alert.FieldSourceLongitude:
		return m.AddedSourceLongitude()
	case alert.FieldCapacity:
		return m.AddedCapacity()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AlertMutation) AddField(name string, value ent.Value) error {
	switch name {
	case alert.FieldEventsCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEventsCount(v)
		return nil
	case alert.FieldSourceLatitude:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceLatitude(v)
		return nil
	case alert.FieldSourceLongitude:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceLongitude(v)
		return nil
	case alert.FieldCapacity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown Alert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AlertMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alert.FieldBucketId) {
		fields = append(fields, alert.FieldBucketId)
	}
	if m.FieldCleared(alert.FieldMessage) {
		fields = append(fields, alert.FieldMessage)
	}
	if m.FieldCleared(alert.FieldEventsCount) {
		fields = append(fields, alert.FieldEventsCount)
	}
	if m.FieldCleared(alert.FieldStartedAt) {
		fields = append(fields, alert.FieldStartedAt)
	}
	if m.FieldCleared(alert.FieldStoppedAt) {
		fields = append(fields, alert.FieldStoppedAt)
	}
	if m.FieldCleared(alert.FieldSourceIp) {
		fields = append(fields, alert.FieldSourceIp)
	}
	if m.FieldCleared(alert.FieldSourceRange) {
		fields = append(fields, alert.FieldSourceRange)
	}
	if m.FieldCleared(alert.FieldSourceAsNumber) {
		fields = append(fields, alert.FieldSourceAsNumber)
	}
	if m.FieldCleared(alert.FieldSourceAsName) {
		fields = append(fields, alert.FieldSourceAsName)
	}
	if m.FieldCleared(alert.FieldSourceCountry) {
		fields = append(fields, alert.FieldSourceCountry)
	}
	if m.FieldCleared(alert.FieldSourceLatitude) {
		fields = append(fields, alert.FieldSourceLatitude)
	}
	if m.FieldCleared(alert.FieldSourceLongitude) {
		fields = append(fields, alert.FieldSourceLongitude)
	}
	if m.FieldCleared(alert.FieldSourceScope) {
		fields = append(fields, alert.FieldSourceScope)
	}
	if m.FieldCleared(alert.FieldSourceValue) {
		fields = append(fields, alert.FieldSourceValue)
	}
	if m.FieldCleared(alert.FieldCapacity) {
		fields = append(fields, alert.FieldCapacity)
	}
	if m.FieldCleared(alert.FieldLeakSpeed) {
		fields = append(fields, alert.FieldLeakSpeed)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AlertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertMutation) ClearField(name string) error {
	switch name {
	case alert.FieldBucketId:
		m.ClearBucketId()
		return nil
	case alert.FieldMessage:
		m.ClearMessage()
		return nil
	case alert.FieldEventsCount:
		m.ClearEventsCount()
		return nil
	case alert.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case alert.FieldStoppedAt:
		m.ClearStoppedAt()
		return nil
	case alert.FieldSourceIp:
		m.ClearSourceIp()
		return nil
	case alert.FieldSourceRange:
		m.ClearSourceRange()
		return nil
	case alert.FieldSourceAsNumber:
		m.ClearSourceAsNumber()
		return nil
	case alert.FieldSourceAsName:
		m.ClearSourceAsName()
		return nil
	case alert.FieldSourceCountry:
		m.ClearSourceCountry()
		return nil
	case alert.FieldSourceLatitude:
		m.ClearSourceLatitude()
		return nil
	case alert.FieldSourceLongitude:
		m.ClearSourceLongitude()
		return nil
	case alert.FieldSourceScope:
		m.ClearSourceScope()
		return nil
	case alert.FieldSourceValue:
		m.ClearSourceValue()
		return nil
	case alert.FieldCapacity:
		m.ClearCapacity()
		return nil
	case alert.FieldLeakSpeed:
		m.ClearLeakSpeed()
		return nil
	}
	return fmt.Errorf("unknown Alert nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AlertMutation) ResetField(name string) error {
	switch name {
	case alert.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case alert.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case alert.FieldScenario:
		m.ResetScenario()
		return nil
	case alert.FieldBucketId:
		m.ResetBucketId()
		return nil
	case alert.FieldMessage:
		m.ResetMessage()
		return nil
	case alert.FieldEventsCount:
		m.ResetEventsCount()
		return nil
	case alert.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case alert.FieldStoppedAt:
		m.ResetStoppedAt()
		return nil
	case alert.FieldSourceIp:
		m.ResetSourceIp()
		return nil
	case alert.FieldSourceRange:
		m.ResetSourceRange()
		return nil
	case alert.FieldSourceAsNumber:
		m.ResetSourceAsNumber()
		return nil
	case alert.FieldSourceAsName:
		m.ResetSourceAsName()
		return nil
	case alert.FieldSourceCountry:
		m.ResetSourceCountry()
		return nil
	case alert.FieldSourceLatitude:
		m.ResetSourceLatitude()
		return nil
	case alert.FieldSourceLongitude:
		m.ResetSourceLongitude()
		return nil
	case alert.FieldSourceScope:
		m.ResetSourceScope()
		return nil
	case alert.FieldSourceValue:
		m.ResetSourceValue()
		return nil
	case alert.FieldCapacity:
		m.ResetCapacity()
		return nil
	case alert.FieldLeakSpeed:
		m.ResetLeakSpeed()
		return nil
	}
	return fmt.Errorf("unknown Alert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AlertMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, alert.EdgeOwner)
	}
	if m.decisions != nil {
		edges = append(edges, alert.EdgeDecisions)
	}
	if m.events != nil {
		edges = append(edges, alert.EdgeEvents)
	}
	if m.metas != nil {
		edges = append(edges, alert.EdgeMetas)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AlertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alert.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case alert.EdgeDecisions:
		ids := make([]ent.Value, 0, len(m.decisions))
		for id := range m.decisions {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeMetas:
		ids := make([]ent.Value, 0, len(m.metas))
		for id := range m.metas {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AlertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddecisions != nil {
		edges = append(edges, alert.EdgeDecisions)
	}
	if m.removedevents != nil {
		edges = append(edges, alert.EdgeEvents)
	}
	if m.removedmetas != nil {
		edges = append(edges, alert.EdgeMetas)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AlertMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case alert.EdgeDecisions:
		ids := make([]ent.Value, 0, len(m.removeddecisions))
		for id := range m.removeddecisions {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeMetas:
		ids := make([]ent.Value, 0, len(m.removedmetas))
		for id := range m.removedmetas {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AlertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, alert.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AlertMutation) EdgeCleared(name string) bool {
	switch name {
	case alert.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AlertMutation) ClearEdge(name string) error {
	switch name {
	case alert.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Alert unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AlertMutation) ResetEdge(name string) error {
	switch name {
	case alert.EdgeOwner:
		m.ResetOwner()
		return nil
	case alert.EdgeDecisions:
		m.ResetDecisions()
		return nil
	case alert.EdgeEvents:
		m.ResetEvents()
		return nil
	case alert.EdgeMetas:
		m.ResetMetas()
		return nil
	}
	return fmt.Errorf("unknown Alert edge %s", name)
}

// BlockerMutation represents an operation that mutate the Blockers
// nodes in the graph.
type BlockerMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	api_key       *string
	revoked       *bool
	ip_address    *string
	_type         *string
	until         *time.Time
	last_pull     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Blocker, error)
}

var _ ent.Mutation = (*BlockerMutation)(nil)

// blockerOption allows to manage the mutation configuration using functional options.
type blockerOption func(*BlockerMutation)

// newBlockerMutation creates new mutation for $n.Name.
func newBlockerMutation(c config, op Op, opts ...blockerOption) *BlockerMutation {
	m := &BlockerMutation{
		config:        c,
		op:            op,
		typ:           TypeBlocker,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockerID sets the id field of the mutation.
func withBlockerID(id int) blockerOption {
	return func(m *BlockerMutation) {
		var (
			err   error
			once  sync.Once
			value *Blocker
		)
		m.oldValue = func(ctx context.Context) (*Blocker, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blocker.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlocker sets the old Blocker of the mutation.
func withBlocker(node *Blocker) blockerOption {
	return func(m *BlockerMutation) {
		m.oldValue = func(context.Context) (*Blocker, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BlockerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *BlockerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *BlockerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Blocker.
// If the Blocker object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *BlockerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *BlockerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *BlockerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Blocker.
// If the Blocker object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *BlockerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the name field.
func (m *BlockerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *BlockerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Blocker.
// If the Blocker object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *BlockerMutation) ResetName() {
	m.name = nil
}

// SetAPIKey sets the api_key field.
func (m *BlockerMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the api_key value in the mutation.
func (m *BlockerMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old api_key value of the Blocker.
// If the Blocker object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockerMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAPIKey is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey reset all changes of the "api_key" field.
func (m *BlockerMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetRevoked sets the revoked field.
func (m *BlockerMutation) SetRevoked(b bool) {
	m.revoked = &b
}

// Revoked returns the revoked value in the mutation.
func (m *BlockerMutation) Revoked() (r bool, exists bool) {
	v := m.revoked
	if v == nil {
		return
	}
	return *v, true
}

// OldRevoked returns the old revoked value of the Blocker.
// If the Blocker object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockerMutation) OldRevoked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRevoked is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRevoked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevoked: %w", err)
	}
	return oldValue.Revoked, nil
}

// ResetRevoked reset all changes of the "revoked" field.
func (m *BlockerMutation) ResetRevoked() {
	m.revoked = nil
}

// SetIPAddress sets the ip_address field.
func (m *BlockerMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the ip_address value in the mutation.
func (m *BlockerMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old ip_address value of the Blocker.
// If the Blocker object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockerMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIPAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of ip_address.
func (m *BlockerMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[blocker.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the field ip_address was cleared in this mutation.
func (m *BlockerMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[blocker.FieldIPAddress]
	return ok
}

// ResetIPAddress reset all changes of the "ip_address" field.
func (m *BlockerMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, blocker.FieldIPAddress)
}

// SetType sets the type field.
func (m *BlockerMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *BlockerMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the Blocker.
// If the Blocker object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockerMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of type.
func (m *BlockerMutation) ClearType() {
	m._type = nil
	m.clearedFields[blocker.FieldType] = struct{}{}
}

// TypeCleared returns if the field type was cleared in this mutation.
func (m *BlockerMutation) TypeCleared() bool {
	_, ok := m.clearedFields[blocker.FieldType]
	return ok
}

// ResetType reset all changes of the "type" field.
func (m *BlockerMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, blocker.FieldType)
}

// SetUntil sets the until field.
func (m *BlockerMutation) SetUntil(t time.Time) {
	m.until = &t
}

// Until returns the until value in the mutation.
func (m *BlockerMutation) Until() (r time.Time, exists bool) {
	v := m.until
	if v == nil {
		return
	}
	return *v, true
}

// OldUntil returns the old until value of the Blocker.
// If the Blocker object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockerMutation) OldUntil(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUntil is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUntil: %w", err)
	}
	return oldValue.Until, nil
}

// ClearUntil clears the value of until.
func (m *BlockerMutation) ClearUntil() {
	m.until = nil
	m.clearedFields[blocker.FieldUntil] = struct{}{}
}

// UntilCleared returns if the field until was cleared in this mutation.
func (m *BlockerMutation) UntilCleared() bool {
	_, ok := m.clearedFields[blocker.FieldUntil]
	return ok
}

// ResetUntil reset all changes of the "until" field.
func (m *BlockerMutation) ResetUntil() {
	m.until = nil
	delete(m.clearedFields, blocker.FieldUntil)
}

// SetLastPull sets the last_pull field.
func (m *BlockerMutation) SetLastPull(t time.Time) {
	m.last_pull = &t
}

// LastPull returns the last_pull value in the mutation.
func (m *BlockerMutation) LastPull() (r time.Time, exists bool) {
	v := m.last_pull
	if v == nil {
		return
	}
	return *v, true
}

// OldLastPull returns the old last_pull value of the Blocker.
// If the Blocker object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockerMutation) OldLastPull(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastPull is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastPull requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastPull: %w", err)
	}
	return oldValue.LastPull, nil
}

// ResetLastPull reset all changes of the "last_pull" field.
func (m *BlockerMutation) ResetLastPull() {
	m.last_pull = nil
}

// Op returns the operation name.
func (m *BlockerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Blocker).
func (m *BlockerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BlockerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, blocker.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blocker.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, blocker.FieldName)
	}
	if m.api_key != nil {
		fields = append(fields, blocker.FieldAPIKey)
	}
	if m.revoked != nil {
		fields = append(fields, blocker.FieldRevoked)
	}
	if m.ip_address != nil {
		fields = append(fields, blocker.FieldIPAddress)
	}
	if m._type != nil {
		fields = append(fields, blocker.FieldType)
	}
	if m.until != nil {
		fields = append(fields, blocker.FieldUntil)
	}
	if m.last_pull != nil {
		fields = append(fields, blocker.FieldLastPull)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BlockerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blocker.FieldCreatedAt:
		return m.CreatedAt()
	case blocker.FieldUpdatedAt:
		return m.UpdatedAt()
	case blocker.FieldName:
		return m.Name()
	case blocker.FieldAPIKey:
		return m.APIKey()
	case blocker.FieldRevoked:
		return m.Revoked()
	case blocker.FieldIPAddress:
		return m.IPAddress()
	case blocker.FieldType:
		return m.GetType()
	case blocker.FieldUntil:
		return m.Until()
	case blocker.FieldLastPull:
		return m.LastPull()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BlockerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blocker.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blocker.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blocker.FieldName:
		return m.OldName(ctx)
	case blocker.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case blocker.FieldRevoked:
		return m.OldRevoked(ctx)
	case blocker.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case blocker.FieldType:
		return m.OldType(ctx)
	case blocker.FieldUntil:
		return m.OldUntil(ctx)
	case blocker.FieldLastPull:
		return m.OldLastPull(ctx)
	}
	return nil, fmt.Errorf("unknown Blocker field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BlockerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blocker.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blocker.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blocker.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case blocker.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case blocker.FieldRevoked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevoked(v)
		return nil
	case blocker.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case blocker.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case blocker.FieldUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUntil(v)
		return nil
	case blocker.FieldLastPull:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastPull(v)
		return nil
	}
	return fmt.Errorf("unknown Blocker field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BlockerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BlockerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BlockerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Blocker numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BlockerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blocker.FieldIPAddress) {
		fields = append(fields, blocker.FieldIPAddress)
	}
	if m.FieldCleared(blocker.FieldType) {
		fields = append(fields, blocker.FieldType)
	}
	if m.FieldCleared(blocker.FieldUntil) {
		fields = append(fields, blocker.FieldUntil)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BlockerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockerMutation) ClearField(name string) error {
	switch name {
	case blocker.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case blocker.FieldType:
		m.ClearType()
		return nil
	case blocker.FieldUntil:
		m.ClearUntil()
		return nil
	}
	return fmt.Errorf("unknown Blocker nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BlockerMutation) ResetField(name string) error {
	switch name {
	case blocker.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blocker.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blocker.FieldName:
		m.ResetName()
		return nil
	case blocker.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case blocker.FieldRevoked:
		m.ResetRevoked()
		return nil
	case blocker.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case blocker.FieldType:
		m.ResetType()
		return nil
	case blocker.FieldUntil:
		m.ResetUntil()
		return nil
	case blocker.FieldLastPull:
		m.ResetLastPull()
		return nil
	}
	return fmt.Errorf("unknown Blocker field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BlockerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BlockerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BlockerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BlockerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BlockerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BlockerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BlockerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Blocker unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BlockerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Blocker edge %s", name)
}

// DecisionMutation represents an operation that mutate the Decisions
// nodes in the graph.
type DecisionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	until         *time.Time
	scenario      *string
	_type         *string
	start_ip      *int64
	addstart_ip   *int64
	end_ip        *int64
	addend_ip     *int64
	scope         *string
	target        *string
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Decision, error)
}

var _ ent.Mutation = (*DecisionMutation)(nil)

// decisionOption allows to manage the mutation configuration using functional options.
type decisionOption func(*DecisionMutation)

// newDecisionMutation creates new mutation for $n.Name.
func newDecisionMutation(c config, op Op, opts ...decisionOption) *DecisionMutation {
	m := &DecisionMutation{
		config:        c,
		op:            op,
		typ:           TypeDecision,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDecisionID sets the id field of the mutation.
func withDecisionID(id int) decisionOption {
	return func(m *DecisionMutation) {
		var (
			err   error
			once  sync.Once
			value *Decision
		)
		m.oldValue = func(ctx context.Context) (*Decision, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Decision.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDecision sets the old Decision of the mutation.
func withDecision(node *Decision) decisionOption {
	return func(m *DecisionMutation) {
		m.oldValue = func(context.Context) (*Decision, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DecisionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DecisionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DecisionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *DecisionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *DecisionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Decision.
// If the Decision object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DecisionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *DecisionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *DecisionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *DecisionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Decision.
// If the Decision object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DecisionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *DecisionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUntil sets the until field.
func (m *DecisionMutation) SetUntil(t time.Time) {
	m.until = &t
}

// Until returns the until value in the mutation.
func (m *DecisionMutation) Until() (r time.Time, exists bool) {
	v := m.until
	if v == nil {
		return
	}
	return *v, true
}

// OldUntil returns the old until value of the Decision.
// If the Decision object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DecisionMutation) OldUntil(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUntil is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUntil: %w", err)
	}
	return oldValue.Until, nil
}

// ResetUntil reset all changes of the "until" field.
func (m *DecisionMutation) ResetUntil() {
	m.until = nil
}

// SetScenario sets the scenario field.
func (m *DecisionMutation) SetScenario(s string) {
	m.scenario = &s
}

// Scenario returns the scenario value in the mutation.
func (m *DecisionMutation) Scenario() (r string, exists bool) {
	v := m.scenario
	if v == nil {
		return
	}
	return *v, true
}

// OldScenario returns the old scenario value of the Decision.
// If the Decision object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DecisionMutation) OldScenario(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScenario is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScenario requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenario: %w", err)
	}
	return oldValue.Scenario, nil
}

// ResetScenario reset all changes of the "scenario" field.
func (m *DecisionMutation) ResetScenario() {
	m.scenario = nil
}

// SetType sets the type field.
func (m *DecisionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *DecisionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the Decision.
// If the Decision object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DecisionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *DecisionMutation) ResetType() {
	m._type = nil
}

// SetStartIP sets the start_ip field.
func (m *DecisionMutation) SetStartIP(i int64) {
	m.start_ip = &i
	m.addstart_ip = nil
}

// StartIP returns the start_ip value in the mutation.
func (m *DecisionMutation) StartIP() (r int64, exists bool) {
	v := m.start_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldStartIP returns the old start_ip value of the Decision.
// If the Decision object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DecisionMutation) OldStartIP(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartIP is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartIP: %w", err)
	}
	return oldValue.StartIP, nil
}

// AddStartIP adds i to start_ip.
func (m *DecisionMutation) AddStartIP(i int64) {
	if m.addstart_ip != nil {
		*m.addstart_ip += i
	} else {
		m.addstart_ip = &i
	}
}

// AddedStartIP returns the value that was added to the start_ip field in this mutation.
func (m *DecisionMutation) AddedStartIP() (r int64, exists bool) {
	v := m.addstart_ip
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartIP clears the value of start_ip.
func (m *DecisionMutation) ClearStartIP() {
	m.start_ip = nil
	m.addstart_ip = nil
	m.clearedFields[decision.FieldStartIP] = struct{}{}
}

// StartIPCleared returns if the field start_ip was cleared in this mutation.
func (m *DecisionMutation) StartIPCleared() bool {
	_, ok := m.clearedFields[decision.FieldStartIP]
	return ok
}

// ResetStartIP reset all changes of the "start_ip" field.
func (m *DecisionMutation) ResetStartIP() {
	m.start_ip = nil
	m.addstart_ip = nil
	delete(m.clearedFields, decision.FieldStartIP)
}

// SetEndIP sets the end_ip field.
func (m *DecisionMutation) SetEndIP(i int64) {
	m.end_ip = &i
	m.addend_ip = nil
}

// EndIP returns the end_ip value in the mutation.
func (m *DecisionMutation) EndIP() (r int64, exists bool) {
	v := m.end_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldEndIP returns the old end_ip value of the Decision.
// If the Decision object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DecisionMutation) OldEndIP(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndIP is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndIP: %w", err)
	}
	return oldValue.EndIP, nil
}

// AddEndIP adds i to end_ip.
func (m *DecisionMutation) AddEndIP(i int64) {
	if m.addend_ip != nil {
		*m.addend_ip += i
	} else {
		m.addend_ip = &i
	}
}

// AddedEndIP returns the value that was added to the end_ip field in this mutation.
func (m *DecisionMutation) AddedEndIP() (r int64, exists bool) {
	v := m.addend_ip
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndIP clears the value of end_ip.
func (m *DecisionMutation) ClearEndIP() {
	m.end_ip = nil
	m.addend_ip = nil
	m.clearedFields[decision.FieldEndIP] = struct{}{}
}

// EndIPCleared returns if the field end_ip was cleared in this mutation.
func (m *DecisionMutation) EndIPCleared() bool {
	_, ok := m.clearedFields[decision.FieldEndIP]
	return ok
}

// ResetEndIP reset all changes of the "end_ip" field.
func (m *DecisionMutation) ResetEndIP() {
	m.end_ip = nil
	m.addend_ip = nil
	delete(m.clearedFields, decision.FieldEndIP)
}

// SetScope sets the scope field.
func (m *DecisionMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the scope value in the mutation.
func (m *DecisionMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old scope value of the Decision.
// If the Decision object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DecisionMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScope is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope reset all changes of the "scope" field.
func (m *DecisionMutation) ResetScope() {
	m.scope = nil
}

// SetTarget sets the target field.
func (m *DecisionMutation) SetTarget(s string) {
	m.target = &s
}

// Target returns the target value in the mutation.
func (m *DecisionMutation) Target() (r string, exists bool) {
	v := m.target
	if v == nil {
		return
	}
	return *v, true
}

// OldTarget returns the old target value of the Decision.
// If the Decision object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DecisionMutation) OldTarget(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTarget is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTarget: %w", err)
	}
	return oldValue.Target, nil
}

// ResetTarget reset all changes of the "target" field.
func (m *DecisionMutation) ResetTarget() {
	m.target = nil
}

// SetOwnerID sets the owner edge to Alert by id.
func (m *DecisionMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Alert.
func (m *DecisionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *DecisionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *DecisionMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *DecisionMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *DecisionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Op returns the operation name.
func (m *DecisionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Decision).
func (m *DecisionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DecisionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, decision.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, decision.FieldUpdatedAt)
	}
	if m.until != nil {
		fields = append(fields, decision.FieldUntil)
	}
	if m.scenario != nil {
		fields = append(fields, decision.FieldScenario)
	}
	if m._type != nil {
		fields = append(fields, decision.FieldType)
	}
	if m.start_ip != nil {
		fields = append(fields, decision.FieldStartIP)
	}
	if m.end_ip != nil {
		fields = append(fields, decision.FieldEndIP)
	}
	if m.scope != nil {
		fields = append(fields, decision.FieldScope)
	}
	if m.target != nil {
		fields = append(fields, decision.FieldTarget)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DecisionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case decision.FieldCreatedAt:
		return m.CreatedAt()
	case decision.FieldUpdatedAt:
		return m.UpdatedAt()
	case decision.FieldUntil:
		return m.Until()
	case decision.FieldScenario:
		return m.Scenario()
	case decision.FieldType:
		return m.GetType()
	case decision.FieldStartIP:
		return m.StartIP()
	case decision.FieldEndIP:
		return m.EndIP()
	case decision.FieldScope:
		return m.Scope()
	case decision.FieldTarget:
		return m.Target()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DecisionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case decision.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case decision.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case decision.FieldUntil:
		return m.OldUntil(ctx)
	case decision.FieldScenario:
		return m.OldScenario(ctx)
	case decision.FieldType:
		return m.OldType(ctx)
	case decision.FieldStartIP:
		return m.OldStartIP(ctx)
	case decision.FieldEndIP:
		return m.OldEndIP(ctx)
	case decision.FieldScope:
		return m.OldScope(ctx)
	case decision.FieldTarget:
		return m.OldTarget(ctx)
	}
	return nil, fmt.Errorf("unknown Decision field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DecisionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case decision.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case decision.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case decision.FieldUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUntil(v)
		return nil
	case decision.FieldScenario:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenario(v)
		return nil
	case decision.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case decision.FieldStartIP:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartIP(v)
		return nil
	case decision.FieldEndIP:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndIP(v)
		return nil
	case decision.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case decision.FieldTarget:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTarget(v)
		return nil
	}
	return fmt.Errorf("unknown Decision field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DecisionMutation) AddedFields() []string {
	var fields []string
	if m.addstart_ip != nil {
		fields = append(fields, decision.FieldStartIP)
	}
	if m.addend_ip != nil {
		fields = append(fields, decision.FieldEndIP)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DecisionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case decision.FieldStartIP:
		return m.AddedStartIP()
	case decision.FieldEndIP:
		return m.AddedEndIP()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DecisionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case decision.FieldStartIP:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartIP(v)
		return nil
	case decision.FieldEndIP:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndIP(v)
		return nil
	}
	return fmt.Errorf("unknown Decision numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DecisionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(decision.FieldStartIP) {
		fields = append(fields, decision.FieldStartIP)
	}
	if m.FieldCleared(decision.FieldEndIP) {
		fields = append(fields, decision.FieldEndIP)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DecisionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DecisionMutation) ClearField(name string) error {
	switch name {
	case decision.FieldStartIP:
		m.ClearStartIP()
		return nil
	case decision.FieldEndIP:
		m.ClearEndIP()
		return nil
	}
	return fmt.Errorf("unknown Decision nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DecisionMutation) ResetField(name string) error {
	switch name {
	case decision.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case decision.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case decision.FieldUntil:
		m.ResetUntil()
		return nil
	case decision.FieldScenario:
		m.ResetScenario()
		return nil
	case decision.FieldType:
		m.ResetType()
		return nil
	case decision.FieldStartIP:
		m.ResetStartIP()
		return nil
	case decision.FieldEndIP:
		m.ResetEndIP()
		return nil
	case decision.FieldScope:
		m.ResetScope()
		return nil
	case decision.FieldTarget:
		m.ResetTarget()
		return nil
	}
	return fmt.Errorf("unknown Decision field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DecisionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, decision.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DecisionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case decision.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DecisionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DecisionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DecisionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, decision.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DecisionMutation) EdgeCleared(name string) bool {
	switch name {
	case decision.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DecisionMutation) ClearEdge(name string) error {
	switch name {
	case decision.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Decision unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DecisionMutation) ResetEdge(name string) error {
	switch name {
	case decision.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Decision edge %s", name)
}

// EventMutation represents an operation that mutate the Events
// nodes in the graph.
type EventMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	time          *time.Time
	serialized    *string
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Event, error)
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows to manage the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for $n.Name.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the id field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Event.
// If the Event object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Event.
// If the Event object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTime sets the time field.
func (m *EventMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the time value in the mutation.
func (m *EventMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old time value of the Event.
// If the Event object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime reset all changes of the "time" field.
func (m *EventMutation) ResetTime() {
	m.time = nil
}

// SetSerialized sets the serialized field.
func (m *EventMutation) SetSerialized(s string) {
	m.serialized = &s
}

// Serialized returns the serialized value in the mutation.
func (m *EventMutation) Serialized() (r string, exists bool) {
	v := m.serialized
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialized returns the old serialized value of the Event.
// If the Event object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventMutation) OldSerialized(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSerialized is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSerialized requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialized: %w", err)
	}
	return oldValue.Serialized, nil
}

// ResetSerialized reset all changes of the "serialized" field.
func (m *EventMutation) ResetSerialized() {
	m.serialized = nil
}

// SetOwnerID sets the owner edge to Alert by id.
func (m *EventMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Alert.
func (m *EventMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *EventMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *EventMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *EventMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *EventMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.time != nil {
		fields = append(fields, event.FieldTime)
	}
	if m.serialized != nil {
		fields = append(fields, event.FieldSerialized)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	case event.FieldTime:
		return m.Time()
	case event.FieldSerialized:
		return m.Serialized()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case event.FieldTime:
		return m.OldTime(ctx)
	case event.FieldSerialized:
		return m.OldSerialized(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case event.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case event.FieldSerialized:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialized(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case event.FieldTime:
		m.ResetTime()
		return nil
	case event.FieldSerialized:
		m.ResetSerialized()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, event.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, event.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// MachineMutation represents an operation that mutate the Machines
// nodes in the graph.
type MachineMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	machineId     *string
	password      *string
	ipAddress     *string
	isValidated   *bool
	status        *string
	clearedFields map[string]struct{}
	alerts        map[int]struct{}
	removedalerts map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Machine, error)
}

var _ ent.Mutation = (*MachineMutation)(nil)

// machineOption allows to manage the mutation configuration using functional options.
type machineOption func(*MachineMutation)

// newMachineMutation creates new mutation for $n.Name.
func newMachineMutation(c config, op Op, opts ...machineOption) *MachineMutation {
	m := &MachineMutation{
		config:        c,
		op:            op,
		typ:           TypeMachine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMachineID sets the id field of the mutation.
func withMachineID(id int) machineOption {
	return func(m *MachineMutation) {
		var (
			err   error
			once  sync.Once
			value *Machine
		)
		m.oldValue = func(ctx context.Context) (*Machine, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Machine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMachine sets the old Machine of the mutation.
func withMachine(node *Machine) machineOption {
	return func(m *MachineMutation) {
		m.oldValue = func(context.Context) (*Machine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MachineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MachineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MachineMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *MachineMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *MachineMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Machine.
// If the Machine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MachineMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *MachineMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *MachineMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *MachineMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Machine.
// If the Machine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MachineMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *MachineMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMachineId sets the machineId field.
func (m *MachineMutation) SetMachineId(s string) {
	m.machineId = &s
}

// MachineId returns the machineId value in the mutation.
func (m *MachineMutation) MachineId() (r string, exists bool) {
	v := m.machineId
	if v == nil {
		return
	}
	return *v, true
}

// OldMachineId returns the old machineId value of the Machine.
// If the Machine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MachineMutation) OldMachineId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMachineId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMachineId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMachineId: %w", err)
	}
	return oldValue.MachineId, nil
}

// ResetMachineId reset all changes of the "machineId" field.
func (m *MachineMutation) ResetMachineId() {
	m.machineId = nil
}

// SetPassword sets the password field.
func (m *MachineMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *MachineMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the Machine.
// If the Machine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MachineMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *MachineMutation) ResetPassword() {
	m.password = nil
}

// SetIpAddress sets the ipAddress field.
func (m *MachineMutation) SetIpAddress(s string) {
	m.ipAddress = &s
}

// IpAddress returns the ipAddress value in the mutation.
func (m *MachineMutation) IpAddress() (r string, exists bool) {
	v := m.ipAddress
	if v == nil {
		return
	}
	return *v, true
}

// OldIpAddress returns the old ipAddress value of the Machine.
// If the Machine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MachineMutation) OldIpAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIpAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIpAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIpAddress: %w", err)
	}
	return oldValue.IpAddress, nil
}

// ResetIpAddress reset all changes of the "ipAddress" field.
func (m *MachineMutation) ResetIpAddress() {
	m.ipAddress = nil
}

// SetIsValidated sets the isValidated field.
func (m *MachineMutation) SetIsValidated(b bool) {
	m.isValidated = &b
}

// IsValidated returns the isValidated value in the mutation.
func (m *MachineMutation) IsValidated() (r bool, exists bool) {
	v := m.isValidated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsValidated returns the old isValidated value of the Machine.
// If the Machine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MachineMutation) OldIsValidated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsValidated is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsValidated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsValidated: %w", err)
	}
	return oldValue.IsValidated, nil
}

// ResetIsValidated reset all changes of the "isValidated" field.
func (m *MachineMutation) ResetIsValidated() {
	m.isValidated = nil
}

// SetStatus sets the status field.
func (m *MachineMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the status value in the mutation.
func (m *MachineMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Machine.
// If the Machine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MachineMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of status.
func (m *MachineMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[machine.FieldStatus] = struct{}{}
}

// StatusCleared returns if the field status was cleared in this mutation.
func (m *MachineMutation) StatusCleared() bool {
	_, ok := m.clearedFields[machine.FieldStatus]
	return ok
}

// ResetStatus reset all changes of the "status" field.
func (m *MachineMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, machine.FieldStatus)
}

// AddAlertIDs adds the alerts edge to Alert by ids.
func (m *MachineMutation) AddAlertIDs(ids ...int) {
	if m.alerts == nil {
		m.alerts = make(map[int]struct{})
	}
	for i := range ids {
		m.alerts[ids[i]] = struct{}{}
	}
}

// RemoveAlertIDs removes the alerts edge to Alert by ids.
func (m *MachineMutation) RemoveAlertIDs(ids ...int) {
	if m.removedalerts == nil {
		m.removedalerts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedalerts[ids[i]] = struct{}{}
	}
}

// RemovedAlerts returns the removed ids of alerts.
func (m *MachineMutation) RemovedAlertsIDs() (ids []int) {
	for id := range m.removedalerts {
		ids = append(ids, id)
	}
	return
}

// AlertsIDs returns the alerts ids in the mutation.
func (m *MachineMutation) AlertsIDs() (ids []int) {
	for id := range m.alerts {
		ids = append(ids, id)
	}
	return
}

// ResetAlerts reset all changes of the "alerts" edge.
func (m *MachineMutation) ResetAlerts() {
	m.alerts = nil
	m.removedalerts = nil
}

// Op returns the operation name.
func (m *MachineMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Machine).
func (m *MachineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MachineMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, machine.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, machine.FieldUpdatedAt)
	}
	if m.machineId != nil {
		fields = append(fields, machine.FieldMachineId)
	}
	if m.password != nil {
		fields = append(fields, machine.FieldPassword)
	}
	if m.ipAddress != nil {
		fields = append(fields, machine.FieldIpAddress)
	}
	if m.isValidated != nil {
		fields = append(fields, machine.FieldIsValidated)
	}
	if m.status != nil {
		fields = append(fields, machine.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MachineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case machine.FieldCreatedAt:
		return m.CreatedAt()
	case machine.FieldUpdatedAt:
		return m.UpdatedAt()
	case machine.FieldMachineId:
		return m.MachineId()
	case machine.FieldPassword:
		return m.Password()
	case machine.FieldIpAddress:
		return m.IpAddress()
	case machine.FieldIsValidated:
		return m.IsValidated()
	case machine.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MachineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case machine.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case machine.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case machine.FieldMachineId:
		return m.OldMachineId(ctx)
	case machine.FieldPassword:
		return m.OldPassword(ctx)
	case machine.FieldIpAddress:
		return m.OldIpAddress(ctx)
	case machine.FieldIsValidated:
		return m.OldIsValidated(ctx)
	case machine.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Machine field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MachineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case machine.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case machine.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case machine.FieldMachineId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMachineId(v)
		return nil
	case machine.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case machine.FieldIpAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIpAddress(v)
		return nil
	case machine.FieldIsValidated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsValidated(v)
		return nil
	case machine.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Machine field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MachineMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MachineMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MachineMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Machine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MachineMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(machine.FieldStatus) {
		fields = append(fields, machine.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MachineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MachineMutation) ClearField(name string) error {
	switch name {
	case machine.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Machine nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MachineMutation) ResetField(name string) error {
	switch name {
	case machine.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case machine.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case machine.FieldMachineId:
		m.ResetMachineId()
		return nil
	case machine.FieldPassword:
		m.ResetPassword()
		return nil
	case machine.FieldIpAddress:
		m.ResetIpAddress()
		return nil
	case machine.FieldIsValidated:
		m.ResetIsValidated()
		return nil
	case machine.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Machine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MachineMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.alerts != nil {
		edges = append(edges, machine.EdgeAlerts)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MachineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case machine.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.alerts))
		for id := range m.alerts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MachineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedalerts != nil {
		edges = append(edges, machine.EdgeAlerts)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MachineMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case machine.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.removedalerts))
		for id := range m.removedalerts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MachineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MachineMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MachineMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Machine unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MachineMutation) ResetEdge(name string) error {
	switch name {
	case machine.EdgeAlerts:
		m.ResetAlerts()
		return nil
	}
	return fmt.Errorf("unknown Machine edge %s", name)
}

// MetaMutation represents an operation that mutate the MetaSlice
// nodes in the graph.
type MetaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	key           *string
	value         *string
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Meta, error)
}

var _ ent.Mutation = (*MetaMutation)(nil)

// metaOption allows to manage the mutation configuration using functional options.
type metaOption func(*MetaMutation)

// newMetaMutation creates new mutation for $n.Name.
func newMetaMutation(c config, op Op, opts ...metaOption) *MetaMutation {
	m := &MetaMutation{
		config:        c,
		op:            op,
		typ:           TypeMeta,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetaID sets the id field of the mutation.
func withMetaID(id int) metaOption {
	return func(m *MetaMutation) {
		var (
			err   error
			once  sync.Once
			value *Meta
		)
		m.oldValue = func(ctx context.Context) (*Meta, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Meta.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMeta sets the old Meta of the mutation.
func withMeta(node *Meta) metaOption {
	return func(m *MetaMutation) {
		m.oldValue = func(context.Context) (*Meta, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MetaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *MetaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *MetaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Meta.
// If the Meta object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MetaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *MetaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *MetaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *MetaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Meta.
// If the Meta object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MetaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *MetaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKey sets the key field.
func (m *MetaMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the key value in the mutation.
func (m *MetaMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old key value of the Meta.
// If the Meta object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MetaMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKey is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey reset all changes of the "key" field.
func (m *MetaMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the value field.
func (m *MetaMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value value in the mutation.
func (m *MetaMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old value value of the Meta.
// If the Meta object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MetaMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue reset all changes of the "value" field.
func (m *MetaMutation) ResetValue() {
	m.value = nil
}

// SetOwnerID sets the owner edge to Alert by id.
func (m *MetaMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Alert.
func (m *MetaMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *MetaMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *MetaMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MetaMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *MetaMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Op returns the operation name.
func (m *MetaMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Meta).
func (m *MetaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MetaMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, meta.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, meta.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, meta.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, meta.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MetaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case meta.FieldCreatedAt:
		return m.CreatedAt()
	case meta.FieldUpdatedAt:
		return m.UpdatedAt()
	case meta.FieldKey:
		return m.Key()
	case meta.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MetaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case meta.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case meta.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case meta.FieldKey:
		return m.OldKey(ctx)
	case meta.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Meta field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MetaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case meta.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case meta.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case meta.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case meta.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Meta field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MetaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MetaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MetaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Meta numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MetaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MetaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Meta nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MetaMutation) ResetField(name string) error {
	switch name {
	case meta.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case meta.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case meta.FieldKey:
		m.ResetKey()
		return nil
	case meta.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Meta field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MetaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, meta.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MetaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case meta.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MetaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MetaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MetaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, meta.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MetaMutation) EdgeCleared(name string) bool {
	switch name {
	case meta.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MetaMutation) ClearEdge(name string) error {
	switch name {
	case meta.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Meta unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MetaMutation) ResetEdge(name string) error {
	switch name {
	case meta.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Meta edge %s", name)
}
