package setup

import (
	"bytes"
	"github.com/mohae/deepcopy"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"slices"
	"sort"

	"github.com/blackfireio/osinfo"
	"github.com/expr-lang/expr"
	log "github.com/sirupsen/logrus"
	goccyyaml "github.com/goccy/go-yaml"
	"gopkg.in/yaml.v3"

	"github.com/crowdsecurity/crowdsec/pkg/acquisition"
	"github.com/crowdsecurity/crowdsec/pkg/acquisition/configuration"
)

// ExecCommand can be replaced with a mock during tests.
var ExecCommand = exec.Command

// HubSpec contains the items (mostly collections) that are recommended to support a service.
type HubSpec map[string][]string

var (
	ErrEmptyDatasourceConfig = errors.New("datasource configuration is empty")
	ErrMissingAcquisitionFilename = errors.New("a filename for the datasource configuration is mandatory")
)

type DatasourceConfig map[string]any

// Validate checks if the DataSourceItem represents a valid configuration for an acquisition.DataSource.
func (d DatasourceConfig) Validate() error {
	if len(d) == 0 {
		return ErrEmptyDatasourceConfig
	}

	// formally validate YAML

	commonDS := configuration.DataSourceCommonCfg{}

	body, err := yaml.Marshal(d)
	if err != nil {
		return err
	}

	err = yaml.Unmarshal(body, &commonDS)
	if err != nil {
		return err
	}

	// source is mandatory // XXX unless it's not?

	if commonDS.Source == "" {
		return errors.New("source is empty")
	}

	// source must be known

	ds, err := acquisition.GetDataSourceIface(commonDS.Source)
	if err != nil {
		return err
	}

	// unmarshal and validate the rest with the specific implementation

	err = ds.UnmarshalConfig(body)
	if err != nil {
		return err
	}

	return nil
}

// Acquisition contains the datasource configuration to support a detected service.
type AcquisitionSpec struct {
	Filename string
	Datasource DatasourceConfig
}

const generatedAcquisitionMarker = `
#
# Configuration generated by "cscli setup".
# XXX: to modify etc.etc.
#
`

func (a *AcquisitionSpec) Path(toDir string) (string, error) {
	if a.Filename == "" {
		return "", errors.New("empty acquisition filename")
	}

	return filepath.Join(toDir, "setup."+a.Filename), nil
}

func (a *AcquisitionSpec) ToYAML() ([]byte, error) {
	out, err := goccyyaml.MarshalWithOptions(a.Datasource, goccyyaml.IndentSequence(true))
	if err != nil {
		return nil, fmt.Errorf("while encoding datasource: %w", err)
	}

	return out, nil
}

func (a *AcquisitionSpec) WriteTo(toDir string) error {
	info, err := os.Stat(toDir)
	if err != nil {
		return err
	}

	// check explicitly because os.Create would report the same error with the file's path instead of the directory's path
	if !info.IsDir() {
		return fmt.Errorf("open %s: not a directory", toDir)
	}

	path, err := a.Path(toDir)
	if err != nil {
		return err
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("creating acquisition file: %w", err)
	}
	defer f.Close()

	_, err = f.WriteString(generatedAcquisitionMarker)
	if err != nil {
		return fmt.Errorf("while writing to %s: %w", path, err)
	}

	content, err := a.ToYAML()
	if err != nil {
		return err
	}

	_, err = f.Write(content)
	if err != nil {
		return fmt.Errorf("while writing to %s: %w", path, err)
	}

	if err = f.Sync(); err != nil {
		return fmt.Errorf("while syncing %s: %w", path, err)
	}

	return nil
}

type InstallRecommendation struct {
	HubSpec         HubSpec         `yaml:"install,omitempty"`
	AcquisitionSpec AcquisitionSpec `yaml:"acquisition,omitempty"`
}

// ServicePlan describes the actions to perform for a detected service.
type ServicePlan struct {
	Name       string     `yaml:"detected_service"`
	InstallRecommendation `yaml:",inline"`
}

// XXX: TODO: Setup is not validated in any way. it can contain non-existent items, malformed acquisition etc.

// Setup is a container for a list of ServicePlan objects, allowing for future extensions.
type Setup struct {
	Plans []ServicePlan `yaml:"setup"`
}

func (s *Setup) CollectHubSpecs() []HubSpec {
	ret := []HubSpec{}

	for _, svc := range s.Plans {
		ret = append(ret, svc.HubSpec)
	}

	return ret
}

func (s *Setup) CollectAcquisitionSpecs() []AcquisitionSpec {
	ret := make([]AcquisitionSpec, len(s.Plans))

	for idx, svc := range s.Plans {
		// XXX: assume no filename name conflict
		ret[idx] = svc.AcquisitionSpec
	}

	return ret
}

func (s *Setup) DetectedServices() []string {
	ret := make([]string, 0, len(s.Plans))

	for _, svc := range s.Plans {
		ret = append(ret, svc.Name)
	}

	slices.Sort(ret)

	return ret
}

func NewSetupFromYAML(input io.Reader, showSource bool, wantColor bool) (Setup, error) {
	inputBytes, err := io.ReadAll(input)
	if err != nil {
		return Setup{}, fmt.Errorf("while reading setup file: %w", err)
	}

	// parse with goccy to have better error messages in many cases
	dec := goccyyaml.NewDecoder(bytes.NewBuffer(inputBytes), goccyyaml.Strict())

	s := Setup{}

	if err := dec.Decode(&s); err != nil {
		return Setup{}, fmt.Errorf("%v", goccyyaml.FormatError(err, wantColor, showSource))
	}

	// parse again because goccy is not strict enough anyway
	dec2 := yaml.NewDecoder(bytes.NewBuffer(inputBytes))
	dec2.KnownFields(true)

	if err := dec2.Decode(&s); err != nil {
		return Setup{}, fmt.Errorf("while parsing setup file: %w", err)
	}

	return s, nil
}

func (s *Setup) ToYAML(outYaml bool) ([]byte, error) {
	var (
		ret []byte
		err error
	)

	indentLevel := 2
	buf := &bytes.Buffer{}
	enc := yaml.NewEncoder(buf)
	enc.SetIndent(indentLevel)

	if err = enc.Encode(s); err != nil {
		return nil, err
	}

	if err = enc.Close(); err != nil {
		return nil, err
	}

	ret = buf.Bytes()

	if !outYaml {
		// take a general approach to output json, so we avoid the
		// double tags in the structures and can use go-yaml features
		// missing from the json package
		ret, err = goccyyaml.YAMLToJSON(ret)
		if err != nil {
			return nil, err
		}
	}

	return ret, nil
}

// Detector is generated from the detection rules (detect.yaml) and can generate the setup plan.
type Detector struct {
	Version string                  `yaml:"version"`
	Detect  map[string]ServiceRules `yaml:"detect"`
}

func NewDetector(detectReader io.Reader) (*Detector, error) {
	d := Detector{}

	yamlBytes, err := io.ReadAll(detectReader)
	if err != nil {
		return nil, err
	}

	dec := yaml.NewDecoder(bytes.NewBuffer(yamlBytes))
	dec.KnownFields(true)

	if err = dec.Decode(&d); err != nil {
		return nil, err
	}

	switch d.Version {
	case "":
		return nil, errors.New("missing version tag (must be 1.0)")
	case "1.0":
		// all is well
	default:
		return nil, fmt.Errorf("invalid version tag '%s' (must be 1.0)", d.Version)
	}

	for name, svc := range d.Detect {
		if svc.AcquisitionSpec.Filename == "" {
			if len(svc.AcquisitionSpec.Datasource) == 0 {
				// missing acquisition is ok - only hub items
				continue
			}

			// if a datasource is specified, we must have a filename
			return nil, fmt.Errorf("invalid acquisition spec for %s: %w", name, ErrMissingAcquisitionFilename)
		}

		// but empty datasource config is not ok
		if err := svc.AcquisitionSpec.Datasource.Validate(); err != nil {
			return nil, fmt.Errorf("invalid acquisition spec for %s: %w", name, err)
		}
	}

	return &d, nil
}

// ListSupportedServices returns a list of the services recognized by the detector.
func (d *Detector) ListSupportedServices() []string {
	keys := make([]string, 0)
	for k := range d.Detect {
		keys = append(keys, k)
	}

	sort.Strings(keys)

	return keys
}

func NewSetup(detector *Detector, opts DetectOptions) (*Setup, error) {
	s := Setup{}

	// explicitly initialize to avoid json marshaling an empty slice as "null"
	s.Plans = make([]ServicePlan, 0)

	os := opts.ForcedOS
	if os == (ExprOS{}) {
		osfull, err := osinfo.GetOSInfo()
		if err != nil {
			return nil, fmt.Errorf("detecting OS: %w", err)
		}

		log.Tracef("Detected OS - %+v", *osfull)

		os = ExprOS{
			Family:     osfull.Family,
			ID:         osfull.ID,
			RawVersion: osfull.Version,
		}
	} else {
		log.Tracef("Forced OS - %+v", os)
	}

	if len(opts.ForcedUnits) > 0 {
		log.Tracef("Forced units - %v", opts.ForcedUnits)
	}

	if len(opts.ForcedProcesses) > 0 {
		log.Tracef("Forced processes - %v", opts.ForcedProcesses)
	}

	env := NewExprEnvironment(opts, os)

	detected, err := buildPlans(detector, env)
	if err != nil {
		return nil, err
	}

	if err = checkConsumedForcedItems(env); err != nil {
		return nil, err
	}

	// remove services the user asked to ignore
	for _, name := range opts.SkipServices {
		delete(detected, name)
	}

	// sort the keys (service names) to have them in a predictable
	// order in the final output

	keys := make([]string, 0)
	for k := range detected {
		keys = append(keys, k)
	}

	sort.Strings(keys)

	for _, name := range keys {
		s.Plans = append(s.Plans, detected[name])
	}

	return &s, nil
}

// ServiceRules describes the rules for detecting a service and its recommended items.
type ServiceRules struct {
	When []string         `yaml:"when"`
	InstallRecommendation `yaml:",inline"`
}

// applyRules checks if the 'when' expressions are true and returns a ServiceRules struct,
// augmented with default values and anything that might be useful later on
//
// All expressions are evaluated (no short-circuit) because we want to know if there are errors.
func applyRules(svc ServiceRules, env ExprEnvironment) (ServiceRules, bool, error) {
	// make a copy because we need the original to detect more stuff
	newsvc := deepcopy.Copy(svc).(ServiceRules)
	svcok := true
	env._serviceState = &ExprServiceState{}

	for _, rule := range svc.When {
		out, err := expr.Eval(rule, env)
		log.Tracef("  Rule '%s' -> %t, %v", rule, out, err)

		if err != nil {
			return ServiceRules{}, false, fmt.Errorf("rule '%s': %w", rule, err)
		}

		outbool, ok := out.(bool)
		if !ok {
			return ServiceRules{}, false, fmt.Errorf("rule '%s': type must be a boolean", rule)
		}

		svcok = svcok && outbool
	}

	return newsvc, svcok, nil
}

func buildPlans(detector *Detector, env ExprEnvironment) (map[string]ServicePlan, error) {
	ret := make(map[string]ServicePlan)

	for name := range detector.Detect {
		log.Trace("Evaluating rules for: ", name)

		svc, ok, err := applyRules(detector.Detect[name], env)
		if err != nil {
			return nil, fmt.Errorf("while looking for service %s: %w", name, err)
		}

		if !ok {
			log.Tracef("  Skipping %s", name)

			continue
		}

		log.Tracef("  Detected %s", name)

		ret[name] = ServicePlan{
			Name:                  name,
			InstallRecommendation: svc.InstallRecommendation,
		}
	}

	return ret, nil
}

// DetectOptions contains parameters for the Detect function.
type DetectOptions struct {
	// slice of unit names that we want to force-detect
	ForcedUnits []string
	// slice of process names that we want to force-detect
	ForcedProcesses []string
	ForcedOS        ExprOS
	SkipServices    []string
	SnubSystemd     bool
}
