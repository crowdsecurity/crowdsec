package setup

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	goccyyaml "github.com/goccy/go-yaml"

	"github.com/crowdsecurity/crowdsec/pkg/cwhub"
	"github.com/crowdsecurity/crowdsec/pkg/hubops"
)

// AcquisDocument is created from a ServicePlan. It represents a single YAML document, and can be part of a multi-document file.
type AcquisDocument struct {
	AcquisFilename string
	DataSource     map[string]any
}

// InstallHubItems installs the objects recommended in a setup file.
func InstallHubItems(ctx context.Context, hub *cwhub.Hub, contentProvider cwhub.ContentProvider, stup Setup, interactive, dryRun, showPlan, verbosePlan bool) error {
	plan := hubops.NewActionPlan(hub)

	for _, servicePlan := range stup.Setup {
		install := servicePlan.Install

		if install == nil {
			continue
		}

		for itemType, items := range servicePlan.Install {
			for _, itemName := range items {
				fqName := itemType + ":" + itemName
				item, err  := hub.GetItemFQ(fqName)
				if err != nil {
					return err
				}

				if err := plan.AddCommand(hubops.NewDownloadCommand(item, contentProvider, false)); err != nil {
					return err
				}

				if err := plan.AddCommand(hubops.NewEnableCommand(item, false)); err != nil {
					return err
				}
			}
		}
	}

	return plan.Execute(ctx, interactive, dryRun, showPlan, verbosePlan)
}

// marshalAcquisDocuments creates the monolithic file, or itemized files (if a directory is provided) with the acquisition documents.
func marshalAcquisDocuments(ads []AcquisDocument, toDir string) (string, error) {
	var sb strings.Builder

	dashTerminator := false

	disclaimer := `
#
# This file was automatically generated by "cscli setup datasources".
# You can modify it by hand, but will be responsible for its maintenance.
# To add datasources or logfiles, you can instead write a new configuration
# in the directory defined by acquisition_dir.
#

`

	if toDir == "" {
		sb.WriteString(disclaimer)
	} else {
		_, err := os.Stat(toDir)
		if os.IsNotExist(err) {
			return "", fmt.Errorf("directory %s does not exist", toDir)
		}
	}

	for _, ad := range ads {
		out, err := goccyyaml.MarshalWithOptions(ad.DataSource, goccyyaml.IndentSequence(true))
		if err != nil {
			return "", fmt.Errorf("while encoding datasource: %w", err)
		}

		if toDir != "" {
			if ad.AcquisFilename == "" {
				return "", errors.New("empty acquis filename")
			}

			fname := filepath.Join(toDir, ad.AcquisFilename)
			fmt.Println("creating", fname)

			f, err := os.Create(fname)
			if err != nil {
				return "", fmt.Errorf("creating acquisition file: %w", err)
			}
			defer f.Close()

			_, err = f.WriteString(disclaimer)
			if err != nil {
				return "", fmt.Errorf("while writing to %s: %w", ad.AcquisFilename, err)
			}

			_, err = f.Write(out)
			if err != nil {
				return "", fmt.Errorf("while writing to %s: %w", ad.AcquisFilename, err)
			}

			if err = f.Sync(); err != nil {
				return "", fmt.Errorf("while syncing %s: %w", ad.AcquisFilename, err)
			}

			continue
		}

		if dashTerminator {
			sb.WriteString("---\n")
		}

		sb.Write(out)

		dashTerminator = true
	}

	return sb.String(), nil
}

// DataSources generates the acquisition documents from a setup file.
func DataSources(stup Setup, toDir string) (string, error) {
	ads := make([]AcquisDocument, 0)

	filename := func(basename string, ext string) string {
		if basename == "" {
			return basename
		}

		return basename + ext
	}

	if len(stup.Setup) > 0 && toDir != "" {
		// XXX: interactive
		if err := os.MkdirAll(toDir, 0o700); err != nil {
			return "", err
		}
	}

	for _, servicePlan := range stup.Setup {
		datasource := servicePlan.DataSource

		basename := ""
		if toDir != "" {
			basename = "setup." + servicePlan.Name
		}

		if datasource == nil {
			continue
		}

		ad := AcquisDocument{
			AcquisFilename: filename(basename, ".yaml"),
			DataSource:     datasource,
		}
		ads = append(ads, ad)
	}

	return marshalAcquisDocuments(ads, toDir)
}
